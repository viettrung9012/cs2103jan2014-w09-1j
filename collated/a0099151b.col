//@author: a0099151b



	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\commandformat\AddCommand.java
	 */


public class AddCommand extends CommandFormat {

    private static final String CLASS_NAME = AddCommand.class.getName();

    public AddCommand(CommandType type, String argumentStr)
            throws IllegalArgumentException {
        super(type, argumentStr);
    }

    @Override
    protected String getProperArgument(String properCommand) {

        String log = _argument.getKeywordValueView();
        StringBuilder commandBuilder = new StringBuilder(properCommand);

        LogHelper.log(CLASS_NAME, Level.INFO, log);

        for (StandardKeyword keyword : _argument.getArgumentKeys()) {

            if (_argument.getKeywordValue(keyword) == null) {
                continue;
            }

            if (keyword != SimpleKeyword.DESCRIPTION) {
                commandBuilder = appendKeyword(commandBuilder, keyword);
            } else {
                commandBuilder = appendValue(commandBuilder, keyword);
            }

        }

        return trimmedCommand(commandBuilder);
    }

    @Override
    protected void preProcessArgument() throws ParseException {
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Preprocessing string for description");
        _argumentStr = extractWrappedDescription(_argumentStr);
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\commandformat\AddCommand.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\commandformat\CommandFormat.java
	 */


public abstract class CommandFormat {

    private static final int DESCRIPT_NOT_FOUND = -1;
    protected CommandType _commandType;
    protected String _argumentStr;
    protected Argument _argument;

    // attributes to help with processing command arguments.
    protected boolean _isWrapped;
    private static final String DESCRIPT_END_DELIMIT = "' ";
    private static final String DESCRIPT_START_DELIMIT = " '";
    protected static final String KEYWORD_VALUE_PAIR = "%1$s %2$s";
    private static final String CLASS_NAME = CommandFormat.class.getName();

    /**
     * Attempt to create a CommandKeyword from here. If commandType supplied is
     * not part of the accepted command, an IllegalArgumentException will be
     * thrown.
     * 
     * @param commandType CommandType enum constant
     * @throws IllegalArgumentException if the commandType is not part of the
     * accepted CommandType
     */
    public CommandFormat(CommandType commandType, String argumentStr)
            throws IllegalArgumentException {

        setCommandType(commandType);
        initArgument(argumentStr);
    }

    private void initArgument(String argumentStr) {
        _argument = new Argument();
        _argumentStr = " " + argumentStr + " ";
    }

    protected void setCommandType(CommandType type) {
        _commandType = type;
    }

    // Shared methods that all other CommandKeyword will use

    protected String trimmedCommand(StringBuilder properCommand) {
        return properCommand.toString().trim();
    }

    private StringBuilder appendWord(StringBuilder properCommand, String word) {
        properCommand.append(word);
        properCommand.append(" ");
        return properCommand;
    }

    protected StringBuilder appendValue(StringBuilder properCommand,
            StandardKeyword keyword) {
        String value = _argument.getKeywordValue(keyword).trim();
        return appendWord(properCommand, value);
    }

    protected StringBuilder appendKeyword(StringBuilder properCommand,
            StandardKeyword keyword) {
        String key = keyword.getFormattedKeyword();
        String value = _argument.getKeywordValue(keyword).trim();
        String keyValue = String.format(KEYWORD_VALUE_PAIR, key, value);

        return appendWord(properCommand, keyValue);
    }

    /**
     * Extract and save the description if it's wrapped within a description
     * delimiter. If there is none to be found, the argument will not be altered
     * and returned exactly
     * 
     * @param commandArguments
     * @return The argument without the description
     */
    protected String extractWrappedDescription(String argument)
            throws ParseException {

        StringBuilder argumentStr = new StringBuilder(argument);
        LogHelper.log(CLASS_NAME, Level.INFO, "Checking for segment");
        if (hasSegment(argumentStr)) {
            _isWrapped = true;
            String descript = getDescriptionSegment(argumentStr);
            addSegmentToDescription(descript);
            argumentStr = removeDescriptionSegment(argumentStr);
        }

        return argumentStr.toString();
    }

    private StringBuilder removeDescriptionSegment(StringBuilder argumentStr) {
        int first = getFirstDelimiter(argumentStr);
        int last = getLastDeimiter(argumentStr);
        argumentStr.delete(first + 1, last + 2);
        return argumentStr;
    }

    private void addSegmentToDescription(String descript) throws ParseException {
        ArrayList<String> descriptTokens = tokenize(descript);
        for (int i = 0; i < descriptTokens.size(); i++) {
            descriptTokens = addToDescription(descriptTokens, i);
        }
    }

    private String getDescriptionSegment(StringBuilder argumentStr) {

        int start = getFirstDelimiter(argumentStr) + DESCRIPT_START_DELIMIT
                .length();
        int end = getLastDeimiter(argumentStr);

        return argumentStr.substring(start, end);
    }

    private boolean hasSegment(StringBuilder argumentStr) {
        int first = getFirstDelimiter(argumentStr);
        int last = getLastDeimiter(argumentStr);

        return first != DESCRIPT_NOT_FOUND && last > first;
    }

    private int getFirstDelimiter(StringBuilder argumentStr) {
        return argumentStr.indexOf(DESCRIPT_START_DELIMIT);
    }

    private int getLastDeimiter(StringBuilder argumentStr) {
        return argumentStr.lastIndexOf(DESCRIPT_END_DELIMIT);
    }

    protected void initValues() {
        return;
    }

    /**
     * Template method. It's split into three phases, preProcessing(),
     * processArgument() and postProcessing(). The first and the last method is
     * implemented by the developer if need be.
     * 
     * @return the standardised command that can be interpreted by the
     * CommandProcessor
     * @throws ParseException if the CommandFormat is unable to parse and
     * translate the argument
     */
    public String parseArgument() throws ParseException {

        preProcessArgument();
        processKeywordValuePairs();
        return getProperCommand();
    }

    private ArrayList<String> processKeywordValuePairs() throws ParseException {

        ArrayList<String> tokens = tokenize(_argumentStr);
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Getting tokens: " + tokens.toString());

        for (int i = 0; i < tokens.size(); i++) {

            String currWord = tokens.get(i);
            if (currWord == null) {
                continue;
            }

            if (isValidKeyword(currWord)) {
                LogHelper.log(CLASS_NAME, Level.INFO,
                        "Creating keyword: " + currWord);
                tokens = processKeyword(tokens, i, currWord);
            } else if (!_isWrapped) {
                tokens = addToDescription(tokens, i);
            }
        }

        return tokens;

    }

    private ArrayList<String> processKeyword(ArrayList<String> tokens, int i,
            String currWord) throws ParseException {
        
        Keyword newKeyword = createKeyword(currWord);        
        tokens = newKeyword.processKeyword(tokens, i, _argument);
        return tokens;
    }

    private Keyword createKeyword(String currWord) throws ParseException {
        currWord = createFormatedWord(currWord);
        LogHelper.log(CLASS_NAME, Level.INFO, "Creating keyword: " + currWord);
        return KeywordFactory.createKeyword(currWord);
    }

    private boolean isValidKeyword(String currWord) {
        currWord = createFormatedWord(currWord);
        return KeywordFactory.isKeyword(currWord);
    }

    private String createFormatedWord(String currWord) {
        currWord = currWord.toLowerCase();
        if (_isWrapped && !currWord.startsWith(StandardKeyword.DELIMITER)) {
            currWord = StandardKeyword.DELIMITER + currWord;
        }
        return currWord;
    }

    private ArrayList<String> addToDescription(ArrayList<String> tokens, int i)
            throws ParseException {
        String descriptKeyword = SimpleKeyword.DESCRIPTION
                .getFormattedKeyword();
        return processKeyword(tokens, i, descriptKeyword);
    }

    protected ArrayList<String> tokenize(String segment) {
        LogHelper
                .log(CLASS_NAME, Level.INFO, "Segregating segment: " + segment);
        String[] tokens = segment.trim().split(" ");
        ArrayList<String> dTokens = new ArrayList<String>();

        for (int i = 0; i < tokens.length; i++) {
            String token = tokens[i].trim();
            if (!token.equals("")) {
                dTokens.add(token);
            }
        }

        return dTokens;
    }

    protected String getProperCommand() {
        String properCommand = getCommand();
        properCommand = getProperArgument(properCommand); // Sub class needs to
                                                          // implement this
        return formatCommand(properCommand);
    }

    // Utility functions. These functions are shared among all CommandFormat

    private String formatCommand(String properCommand) {
        return properCommand.toString().trim();
    }

    private String getCommand() {
        StringBuilder commandBuilder = new StringBuilder();
        String command = _commandType.getType();
        commandBuilder.append(command);
        commandBuilder.append(" ");
        return commandBuilder.toString();
    }

    // functions that need to be created
    protected abstract void preProcessArgument() throws ParseException;
    protected abstract String getProperArgument(String properCommand);
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\commandformat\CommandFormat.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\commandformat\DisplayCommand.java
	 */

public class DisplayCommand extends AddCommand {

    private static final String CLASS_NAME = DisplayCommand.class.getName();

    private HashMap<String, String> _displayValueAlias;

    public DisplayCommand(CommandType type, String argumentStr)
            throws IllegalArgumentException {
        super(type, argumentStr);
        initDisplayValueAlias();
    }

    private void initDisplayValueAlias() {
        TaskIdKeyword taskIdKeyword = new TaskIdKeyword();
        _displayValueAlias = new HashMap<String, String>();

        _displayValueAlias.put("all", FilterType.COMPLETE_PLUS.getType());
        _displayValueAlias.put("completed", FilterType.COMPLETE.getType());
        _displayValueAlias.putAll(taskIdKeyword.getKeywordValues());
    }

    @Override
    protected void preProcessArgument() throws ParseException {
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Preprocessing string to replace keywords");
        ArrayList<String> tokens;
        tokens = tokenize(_argumentStr);
        tokens = replaceValues(tokens);
        _argumentStr = rebuildString(tokens);
    }

    private String rebuildString(ArrayList<String> tokens) {
        StringBuilder rebuiltString = new StringBuilder();
        for (String token : tokens) {
            rebuiltString.append(token);
            rebuiltString.append(" ");
        }
        return rebuiltString.toString().trim();
    }

    private ArrayList<String> replaceValues(ArrayList<String> tokens) {

        for (int i = 0; i < tokens.size(); i++) {
            String word = tokens.get(i);
            if (_displayValueAlias.containsKey(word)) {
                tokens.set(i, _displayValueAlias.get(word));
            }
        }

        return tokens;
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\commandformat\DisplayCommand.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\commandformat\ModifyCommand.java
	 */

public class ModifyCommand extends CommandFormat {

    private static final String CLASS_NAME = CommandFormat.class.getName();

    public ModifyCommand(CommandType commandType, String argumentStr) {
        super(commandType, argumentStr);
    }

    @Override
    protected void preProcessArgument() throws ParseException {
        _argumentStr = extractWrappedDescription(_argumentStr);
        _argumentStr = preceedTaskIdFlag(_argumentStr);
    }

    private String preceedTaskIdFlag(String argumentStr) {
        StringBuilder argumentBuild = new StringBuilder(argumentStr);
        String taskIdFlag = "-taskid ";
        argumentBuild.insert(0, taskIdFlag, 0, taskIdFlag.length());
        return argumentBuild.toString();
    }

    @Override
    protected String getProperArgument(String properCommand) {
        String log = _argument.getKeywordValueView();
        StringBuilder commandBuilder = new StringBuilder(properCommand);

        LogHelper.log(CLASS_NAME, Level.INFO, log);

        // get taskid, nullify the id so that it wouldn't be added.
        commandBuilder = appendValue(commandBuilder, SimpleKeyword.TASKID);
        _argument.setKeywordValue(SimpleKeyword.TASKID, null);

        for (StandardKeyword keyword : _argument.getArgumentKeys()) {

            if (_argument.getKeywordValue(keyword) == null) {
                continue;
            }

            commandBuilder = appendKeyword(commandBuilder, keyword);

        }

        return trimmedCommand(commandBuilder);
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\commandformat\ModifyCommand.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\commandformat\SearchCommand.java
	 */

public class SearchCommand extends CommandFormat {

    private static final String CLASS_NAME = SearchCommand.class.getName();
    private static final String SEARCH_DELIMIT = "//";

    public SearchCommand(CommandType commandType, String argumentStr)
            throws IllegalArgumentException {
        super(commandType, argumentStr);
    }

    @Override
    protected void preProcessArgument() throws ParseException {
        StringBuilder argBuilder;
        argBuilder = prepArgument(_argumentStr);
        argBuilder = extractSearchTokens(argBuilder);
        _argumentStr = processSearchToken(argBuilder);
    }

    private String processSearchToken(StringBuilder argBuilder) {
        //remove the last '//' 
        int lastDelimiter = argBuilder.lastIndexOf(SEARCH_DELIMIT);
        String result = argBuilder.toString().substring(0, lastDelimiter);
        LogHelper.log(CLASS_NAME, Level.INFO, result);
        return result;
    }

    private StringBuilder extractSearchTokens(StringBuilder argBuilder) {

        StringBuilder searchArg = new StringBuilder();        
        searchArg = extractPhrases(searchArg, argBuilder); 
        searchArg = extractWords(searchArg, argBuilder);
        
        return searchArg;
    }

    private StringBuilder extractWords(StringBuilder searchArg,
                                        StringBuilder argBuilder) {
        
        String words[] = tokenizeString(argBuilder);
        for (int i = 0; i < words.length; i++) {
            String word = words[i].trim();
            if (!word.equals("")) {
                searchArg.append(word);
                searchArg.append(SEARCH_DELIMIT);
            }
        }
        return searchArg;
    }

    private StringBuilder extractPhrases(StringBuilder searchArg, StringBuilder argBuilder) {
                
        ArrayList<String> phrases = getPhrases(argBuilder);
        searchArg = processPhrases(phrases, searchArg);

        return searchArg;
    }

    private StringBuilder processPhrases(ArrayList<String> phrases, StringBuilder searchArg) {
        
        for (String phrase : phrases) {
            phrase = phrase.trim();
            int first = phrase.indexOf("'");
            int last = phrase.lastIndexOf("'");
            phrase = phrase.substring(first + 1, last);
            searchArg.append(phrase.trim());
            searchArg.append(SEARCH_DELIMIT);
        }
        
        return searchArg;
    }

    private ArrayList<String> getPhrases(StringBuilder argBuilder) {
        
        Pattern phrasePattern = Pattern.compile("\\s'.*?'\\s");
        Matcher phraseMatcher = phrasePattern.matcher(argBuilder.toString());
        ArrayList<String> phrases = new ArrayList<String>();
        
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Match count: " + phraseMatcher.groupCount());
        
        //Extract phrases and remove them from the original argument.
        while (phraseMatcher.find()) {
            String match = phraseMatcher.group();
            phrases.add(match);
            LogHelper.log(CLASS_NAME, Level.INFO, match);
            int matchIndex = argBuilder.indexOf(match);
            
            argBuilder.delete(matchIndex + 1, matchIndex + match.length());
            argBuilder.insert(0, " ");
            
            phraseMatcher.reset(argBuilder);
        }
        
        return phrases;
        
    }

    private String[] tokenizeString(StringBuilder rawString) {
        return rawString.toString().trim().split(" ");
    }

    private StringBuilder prepArgument(String argumentStr) {
        String argument = " " + argumentStr + " ";
        argument = argument.replace(StandardKeyword.DELIMITER, StandardKeyword.DELIMITER_ESCAPE);
        return new StringBuilder(argument);

    }

    @Override
    protected String getProperArgument(String properCommand) {
        String value = _argument.getKeywordValue(SimpleKeyword.DESCRIPTION);
        return properCommand + value;
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\commandformat\SearchCommand.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\CommandParser.java
	 */

public class CommandParser {

    private static final CommandType REDO = CommandType.REDO;
    private static final CommandType SEARCH = CommandType.SEARCH;
    private static final CommandType UNDO = CommandType.UNDO;
    private static final CommandType EXIT = CommandType.EXIT;
    private static final CommandType DISPLAY = CommandType.DISPLAY;
    private static final CommandType DELETE = CommandType.DELETE;
    private static final CommandType ADD = CommandType.ADD;
    private static final CommandType MODIFY = CommandType.MODIFY;
    private static final CommandType COMPLETE = CommandType.COMPLETE;

    private static final int ACTION_INDEX = 0;
    private static final int ARG_INDEX = 1;
    private static final String SPACE = " ";

    private static final HashMap<String, CommandType> ACTIONS_KEYWORDS = new HashMap<String, CommandType>();
    private static final HashMap<String, String> SINGLE_ACTION_KEYWORD = new HashMap<String, String>();
    private static final String EMPTY = "";
    private static final String CLASS_NAME = CommandParser.class.getName();

    public CommandParser() {

        KeywordFactory.initialiseKeywordFactory();
        
        initAddCommands();
        initModifyCommands();
        initDeleteCommands();
        initSearchCommands();
        initDisplayCommands();
        initCompleteCommands();
        initSingleActionCommand();
    }

    private void initSingleActionCommand() {
        SINGLE_ACTION_KEYWORD.put(EXIT.getType(), EXIT.getType());
        SINGLE_ACTION_KEYWORD.put("quit", EXIT.getType());
        SINGLE_ACTION_KEYWORD.put(UNDO.getType(), UNDO.getType());
        SINGLE_ACTION_KEYWORD.put(REDO.getType(), REDO.getType());
    }

    private void initCompleteCommands() {
        ACTIONS_KEYWORDS.put(COMPLETE.getType(), COMPLETE);
        ACTIONS_KEYWORDS.put("finish", COMPLETE);
    }

    private void initDisplayCommands() {
        ACTIONS_KEYWORDS.put(DISPLAY.getType(), DISPLAY);
        ACTIONS_KEYWORDS.put("filter", DISPLAY);
        ACTIONS_KEYWORDS.put("show", DISPLAY);
    }

    private void initSearchCommands() {
        ACTIONS_KEYWORDS.put("search", SEARCH);
        ACTIONS_KEYWORDS.put("find", SEARCH);
    }

    private void initDeleteCommands() {
        ACTIONS_KEYWORDS.put("remove", DELETE);
        ACTIONS_KEYWORDS.put("rm", DELETE);
        ACTIONS_KEYWORDS.put("-", DELETE);
        ACTIONS_KEYWORDS.put("delete", DELETE);
    }

    private void initModifyCommands() {
        ACTIONS_KEYWORDS.put("modify", MODIFY);
        ACTIONS_KEYWORDS.put("change", MODIFY);
        ACTIONS_KEYWORDS.put("edit", MODIFY);
    }

    private void initAddCommands() {
        ACTIONS_KEYWORDS.put("add", ADD);
        ACTIONS_KEYWORDS.put("make", ADD);
        ACTIONS_KEYWORDS.put("create", ADD);
        ACTIONS_KEYWORDS.put("new", ADD);
        ACTIONS_KEYWORDS.put("+", ADD);
    }
    
    /**
     * To translate a user input into a form where CommandProcessor could understand.
     * @param userInput
     * @return
     * @throws NullPointerException
     * @throws ParseException
     */
    public String convertCommand(String userInput) throws NullPointerException,
            ParseException {

        checkValidity(userInput);

        String[] rawTokens = getRawTokens(userInput);
        String action = rawTokens[ACTION_INDEX];
        String argument = rawTokens[ARG_INDEX];

        return executeCommand(action, argument);

    }

    private String executeCommand(String action, String argument) throws ParseException {
        
        // short circuit, if the action needs no argument
        if (SINGLE_ACTION_KEYWORD.containsKey(action)) {
            return SINGLE_ACTION_KEYWORD.get(action);
        }

        // Determine action here
        CommandType command = ACTIONS_KEYWORDS.get(action);
        CommandFormat currCommand;

        switch (command) {

            case DISPLAY :
                currCommand = new DisplayCommand(command, argument);
                break;
            case ADD :
                currCommand = new AddCommand(command, argument);
                break;

            case MODIFY :
                // FALLTHROUGH
            case DELETE :
                // FALLTHROUGH
            case COMPLETE :
                currCommand = new ModifyCommand(command, argument);
                break;
            case SEARCH :
                currCommand = new SearchCommand(command, argument);
                break;
            default :
                throw new Error("No such action yet.");

        }

        // execute commandformat and return
        String translatedCommand = currCommand.parseArgument();
        return translatedCommand;
    }

    private String[] getRawTokens(String userInput) {

        String[] rawTokens = userInput.trim().split(SPACE, 2);
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Distinguishing action: " + Arrays.toString(rawTokens));

        if (rawTokens.length < 2) {
            String[] newRawTokens = { rawTokens[ACTION_INDEX], "" };
            rawTokens = newRawTokens;
        }

        rawTokens[ACTION_INDEX] = rawTokens[ACTION_INDEX].toLowerCase();
        rawTokens[ARG_INDEX] = rawTokens[ARG_INDEX].trim();

        return rawTokens;
    }

    private void checkValidity(String userInput) throws ParseException,
            NullPointerException {
        if (userInput == null) {
            throw new NullPointerException();
        }
        if (userInput.equals(EMPTY)) {
            throw new ParseException("Empty String!", 0);
        }
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\CommandParser.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\AgendaOfCompositeKeyword.java
	 */

public class AgendaOfCompositeKeyword extends StartKeyword {
    
    static {
        AgendaOfCompositeKeyword agendaOf = new AgendaOfCompositeKeyword(CompositeKeyword.AGENDAOF);
        KeywordFactory.addAliasEntry("-agendaof", agendaOf);
    }
    
    private static final String START_TIME = "000000";
    private static final String END_TIME = "235959";
    private static final int LOOK_AHEAD_LIMIT = 3;
    
    public AgendaOfCompositeKeyword(StandardKeyword type) {
        super(type);
    }
    
    public AgendaOfCompositeKeyword() {
        super(CompositeKeyword.AGENDAOF);
    }
    
    @Override
    public ArrayList<String> processKeyword(ArrayList<String> tokens,
                                            int currIndex, Argument argument) throws ParseException {
        
        String lookahead = getLookAhead(tokens, currIndex, LOOK_AHEAD_LIMIT);
        String rawDate = parseDateFirst(lookahead);
        checkDate(rawDate);
        
        int argLimit = getArgLimit(rawDate);
        String date = getMilitaryDate(rawDate);
        tokens = updateTokens(tokens, currIndex, argLimit, date);
        return tokens;
    }
    
    private void checkDate(String rawDate) throws ParseException {
        if(rawDate==null){
            throw new ParseException("Invalid date", 0);
        }
    }

    private ArrayList<String> updateTokens(ArrayList<String> tokens,
                                            int currIndex, int argLimit, String date) {
        tokens = nullifyTokens(tokens, currIndex, argLimit);
        tokens = replaceSimpleKeywords(tokens, currIndex,date);
        return tokens;
    }

    private ArrayList<String> replaceSimpleKeywords(ArrayList<String> tokens,
                                                    int currIndex, String date) {
        
        ArrayList<String> startEndSub = new ArrayList<String>();
        
        startEndSub.add("-start");
        startEndSub.add(date + START_TIME);
        startEndSub.add("-end");
        startEndSub.add(date + END_TIME);
        
        tokens.addAll(currIndex + 1, startEndSub);
        return tokens;
    }

    @Override
    public Keyword createKeyword() {
        return new AgendaOfCompositeKeyword();
    }
}



	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\AgendaOfCompositeKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\AllKeyword.java
	 */

public class AllKeyword extends Keyword {
    
    static {
        KeywordFactory.addAliasEntry("-all", new AllKeyword());
    }
    
    public static final String EMPTY_DEFAULT = "";
    
    public AllKeyword (StandardKeyword type) {
        super(type);
    }
    public AllKeyword() {
        this(SimpleKeyword.ALL);
    }
    
    @Override
    protected Keyword createKeyword() {
        return new AllKeyword();
    }

    @Override
    protected void initValues() {
        return;
    }

    @Override
    public ArrayList<String> processKeyword(ArrayList<String> tokens,
            int currIndex, Argument argument) throws ParseException {
        updateArgument(argument);
        tokens = nullifyToken(tokens, currIndex);
        return tokens;
    }

    private ArrayList<String> nullifyToken(ArrayList<String> tokens,
            int currIndex) {
        tokens.set(currIndex, null);
        return tokens;
    }
    
    private void updateArgument(Argument argument) {
        argument.setKeywordValue(SimpleKeyword.ALL, EMPTY_DEFAULT);
    }
    
    @Override
    public Map<String, String> getKeywordValues() {
        return null;
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\AllKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\Argument.java
	 */

public class Argument {
    
    private LinkedHashMap<StandardKeyword, String> _arguments;
    //private static final Logger logger = LogManager.getLogger(Argument.class.getName());
    
    public Argument(){
        initKeywordsMap();
    }
    
    private void initKeywordsMap() {
        _arguments = new LinkedHashMap<StandardKeyword, String>();
        for (SimpleKeyword type: SimpleKeyword.values()) {
            _arguments.put(type, null);
        }
    }
    
    public boolean hasValue(StandardKeyword key) {
        return _arguments.get(key) != null;
    }
    
    public void setKeywordValue(StandardKeyword key, String value) {
        
        if(value==null){
            value = null;
        } else {
            value = value.trim() + " ";
        }
        
        _arguments.put(key, value);
    }
    
    public String getKeywordValue(StandardKeyword key) {
        return _arguments.get(key);
    }
    
    public Set<StandardKeyword> getArgumentKeys() {
        return _arguments.keySet();
    }
     
    public String getKeywordValueView() {
        
        StringBuilder commandLog = new StringBuilder();
        
        for (StandardKeyword keyword: _arguments.keySet()) {
            String entry = keyword + ": " + getKeywordValue(keyword) + " \n";
            commandLog.append(entry);
        }
        
        return commandLog.toString();
    }
    
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\Argument.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\CommandType.java
	 */

public enum CommandType {
    
    UNDO("undo"),
    REDO("redo"),
    EXIT("exit"),
    
    SEARCH("search"),
    DISPLAY("display"),
    DELETE("delete"),
    ADD("add"),
    MODIFY("modify"),
    COMPLETE("complete"),
    UNCOMPLETE("uncomplete"),
    INVALID("invalid");
    
    private String _cmd;
    
    private CommandType(String cmd) {
        _cmd = cmd;
    }
    public String getType() {
        return _cmd;
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\CommandType.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\CompositeKeyword.java
	 */

public enum CompositeKeyword implements StandardKeyword {
    AGENDAOF("AgendaOf"),
    PRIORITY("Priority");
    
    private String _type;
    private CompositeKeyword(String type) {
        _type = type;
    }
    @Override
    public String getFilePrefix() {
        return _type + "Composite";
    }
    @Override
    public String getFormattedKeyword() {
        return DELIMITER + getKeyword();
    }
    @Override
    public String getKeyword() {
        return _type.toLowerCase();
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\CompositeKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\DescriptionKeyword.java
	 */

public class DescriptionKeyword extends Keyword {

    private static final StandardKeyword DESCRIPTION = SimpleKeyword.DESCRIPTION;
    private static final String CLASS_NAME = DescriptionKeyword.class.getName();
    
    static {
        DescriptionKeyword newDescript = new DescriptionKeyword();
        KeywordFactory.addAliasEntry(DESCRIPTION.getFormattedKeyword(),
                newDescript);
    }

    public DescriptionKeyword(StandardKeyword type) {
        super(type);
    }

    public DescriptionKeyword() {
        this(DESCRIPTION);
    }

    @Override
    protected void initValues() {
        return;
    }

    /**
     * Process keyword by using the current tokens and current index For
     * description, tokens are processed one-by-one.
     * 
     * @param tokens The arraylist in question
     * @param currindex the index where the the keyword should start
     * @return the tokens of which all of its
     */
    public ArrayList<String> processKeyword(ArrayList<String> tokens,
            int currIndex, Argument argument) throws ParseException {
        LogHelper.log(CLASS_NAME, Level.INFO, "Adding description");

        String description = extractWord(tokens, currIndex, argument);
        tokens = updateTokens(tokens, currIndex);

        argument.setKeywordValue(_type, description);

        return tokens;
    }

    private ArrayList<String> updateTokens(ArrayList<String> tokens,
            int currIndex) {
        tokens.set(currIndex, null);
        return tokens;
    }

    private String extractWord(ArrayList<String> tokens, int currIndex,
            Argument argument) {

        String oldDescript = argument.getKeywordValue(_type);
        StringBuilder descriptBuilder;

        if (oldDescript == null) {
            descriptBuilder = new StringBuilder();
        } else {
            descriptBuilder = new StringBuilder(oldDescript);
        }

        String word = tokens.get(currIndex);
        word = word.replace(StandardKeyword.DELIMITER, StandardKeyword.DELIMITER_ESCAPE);
        
        LogHelper.log(CLASS_NAME, Level.INFO, "Appending " + word +
                " to " +
                oldDescript);

        descriptBuilder.append(word);

        return descriptBuilder.toString();
    }

    @Override
    protected Keyword createKeyword() {
        return new DescriptionKeyword();
    }

    @Override
    public Map<String, String> getKeywordValues() {
        return null;
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\DescriptionKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\EndKeyword.java
	 */

public class EndKeyword extends StartKeyword {
    
    static {
        EndKeyword endPrototype = new EndKeyword();
        KeywordFactory.addAliasEntry(SimpleKeyword.END.getFormattedKeyword(), endPrototype);
        KeywordFactory.addAliasEntry("-end", endPrototype);
        KeywordFactory.addAliasEntry("-due", endPrototype);
        KeywordFactory.addAliasEntry("-by", endPrototype);
        KeywordFactory.addAliasEntry("-before", endPrototype);
        KeywordFactory.addAliasEntry("-on", endPrototype);
        KeywordFactory.addAliasEntry("-to", endPrototype);
    }
    
    public EndKeyword(StandardKeyword type) {
        super(type);
    }
    
    public EndKeyword(){
        this(SimpleKeyword.END);
        this._defaultTime = "235959";
    }
    
    @Override
    protected Keyword createKeyword() {
        return new EndKeyword();
    }
    
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\EndKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\EveryKeyword.java
	 */

public class EveryKeyword extends Keyword {
    
    private static final int EVERY_LOOKAHEAD_LIMIT = 1;

    private HashMap<String, String> _everyValues;
    
    private static final String EVERY_DAY = "day";
    private static final String EVERY_WEEK = "week";
    private static final String EVERY_MONTH = "month";
    private static final String EVERY_YEAR = "year";
    private static final String EVERY_HOUR = "hour";
    
    static {
        EveryKeyword everyKeyword = new EveryKeyword(SimpleKeyword.RECURRING);
        KeywordFactory.addAliasEntry("-every", everyKeyword);
    }
    
    public EveryKeyword(StandardKeyword type) {
        super(type);
    }
    
    public EveryKeyword() {
        this(SimpleKeyword.RECURRING);
    }
    
    @Override
    protected Keyword createKeyword() {
        return new EveryKeyword();
    }

    @Override
    protected void initValues() {
        
        _everyValues = new HashMap<String, String>();
        
        _everyValues.put(EVERY_DAY, EVERY_DAY);
        _everyValues.put(EVERY_WEEK, EVERY_WEEK);
        _everyValues.put(EVERY_MONTH, EVERY_MONTH);
        _everyValues.put(EVERY_YEAR, EVERY_YEAR);
        _everyValues.put("yr", EVERY_YEAR);
        _everyValues.put(EVERY_HOUR, EVERY_HOUR);
        _everyValues.put("hr", EVERY_HOUR);
    }

    @Override
    public ArrayList<String> processKeyword(ArrayList<String> tokens,
                                            int currIndex, Argument argument) throws ParseException {
        
        String everyKeyword;
        everyKeyword = getLookAhead(tokens, currIndex, EVERY_LOOKAHEAD_LIMIT);
        everyKeyword = getEveryValue(everyKeyword);
        tokens = nullifyTokens(tokens, currIndex); 
        
        updateArgument(everyKeyword, argument);
        
        return tokens;
    }

    private void updateArgument(String everyKeyword, Argument argument) throws ParseException {
        if(!hasExistingKeywordValue(argument)){
            argument.setKeywordValue(_type, everyKeyword);
        } else {
            throw new ParseException(getExistingFlagErr(), 0);
        }
    }

    private ArrayList<String> nullifyTokens(ArrayList<String> tokens, int currIndex) {
        
        int next = currIndex + 1;
        
        tokens.set(currIndex, null);
        if(next<tokens.size()) {
            tokens.set(currIndex+1, null);
        }
        
        return tokens;
    }

    private String getEveryValue(String everyKeyword) throws ParseException{
        String value = _everyValues.get(everyKeyword);
        if(value==null){
            throw new ParseException("No such values", 0);
        } else{
            return value;
        }
    }

    @Override
    public Map<String, String> getKeywordValues() {
        return _everyValues;
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\EveryKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\Keyword.java
	 */

public abstract class Keyword {

    protected StandardKeyword _type;
    protected final static boolean IS_PROTOTYPE = true;
    protected final static boolean IS_NOT_PROTOTYPE = false;
    protected static final int LOOK_AHEAD_LIMIT = 4;
    protected static final String ERR_DUPLICATED_FLAG = "Duplicated flag: %1$s";
    
    public Keyword(StandardKeyword type) {
        _type = type;
        initValues();
    }

    protected String getLookAhead(ArrayList<String> tokens, int currIndex,
            int lookaheadLimit) {

        StringBuilder lookahead = new StringBuilder();

        for (int i = 0, index = currIndex + 1; i < tokens.size() && i < lookaheadLimit &&
                index < tokens.size(); i++, index++) {
            String word = tokens.get(index);
            lookahead.append(word);
            lookahead.append(" ");
        }

        return lookahead.toString().trim();
    }
    
    protected boolean hasExistingKeywordValue(Argument arguments) {
        return arguments.hasValue(_type);
    }
    
    protected String getExistingFlagErr() {
        return String.format(ERR_DUPLICATED_FLAG, _type.getFormattedKeyword());
    }
    
    //Functions that need to be implemented
    protected abstract Keyword createKeyword();

    protected abstract void initValues();

    public abstract ArrayList<String> processKeyword(ArrayList<String> tokens,
            int currIndex, Argument argument) throws ParseException;

    public abstract Map<String, String> getKeywordValues();
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\Keyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\KeywordFactory.java
	 */

public class KeywordFactory {

    private static LinkedHashMap<String, Keyword> _keywordAliasMap = new LinkedHashMap<String, Keyword>();

    private static final String CLASS_NAME = KeywordFactory.class.getName();

    private static final String KEYWORD_CLASS_NAME_TEMPLATE = "sg.edu.nus.cs2103t.mina.commandcontroller.keyword.%1$sKeyword";
    private static final String ERR_CLASS_NOT_FOUND = "Cannot find class: %1$s";

    /**
     * Initialise the KeywordFactory. This method will create the
     * alias-to-Keyword mapping.
     */
    public static void initialiseKeywordFactory() {
        // Update KeywordFactoryTest's invokeInitClasses() method accordingly if
        // you're going to add new entries here
        try {
            initKeywordClasses(SimpleKeyword.values());
            initKeywordClasses(CompositeKeyword.values());
        } catch (ClassNotFoundException e) {
            LogHelper.log(CLASS_NAME, Level.ERROR, e.getMessage());
        }
    }

    private static void initKeywordClasses(StandardKeyword[] values)
            throws ClassNotFoundException {
        for (StandardKeyword type : values) {
            String className = String.format(KEYWORD_CLASS_NAME_TEMPLATE,
                    type.getFilePrefix());

            try {
                Class.forName(className);
            } catch (ClassNotFoundException e) {
                String classNotFoundErr = String.format(ERR_CLASS_NOT_FOUND,
                        className);
                throw new ClassNotFoundException(classNotFoundErr);
            }
        }
    }

    /**
     * Add a standard keyword entry into the KeywordFactory. Note: this method
     * should be invoked only under static initializer of keyword
     * 
     * @param type StandardKeyword enum. It must be found there.
     * @param keyword The Keyword object created. This should be a prototype.
     */
    protected static void addAliasEntry(String alias, Keyword keyword) {
        assert (alias != null && keyword != null);

        LogHelper.log(CLASS_NAME, Level.INFO, "Adding " + alias +
                " and " +
                keyword);
        _keywordAliasMap.put(alias, keyword);
        LogHelper.log(CLASS_NAME, Level.INFO, "Done");
    }

    /**
     * Create the keyword object based on the alias given
     * 
     * @param keyword the alias found e
     * @return The specific keyword object
     */
    public static Keyword createKeyword(String alias) throws ParseException {
        LogHelper.log(CLASS_NAME, Level.INFO,
                alias + " " + _keywordAliasMap.toString());
        Keyword prototype = _keywordAliasMap.get(alias);
        if (prototype == null) {
            throw new ParseException("No such alias/keyword", 0);
        }
        return prototype.createKeyword();
    }

    public static boolean isKeyword(String token) {
        return _keywordAliasMap.containsKey(token);
    }

    /**
     * For testing purpose only. Would need reflection to make it public
     * 
     * @return
     */
    @SuppressWarnings("unused")
    private static LinkedHashMap<String, Keyword> getAliasMap() {
        return _keywordAliasMap;
    }

}
	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\KeywordFactory.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\PriorityCompositeKeyword.java
	 */

public class PriorityCompositeKeyword extends Keyword {

    static {
        PriorityCompositeKeyword priorityComposite = new PriorityCompositeKeyword(
                CompositeKeyword.PRIORITY);
        KeywordFactory.addAliasEntry("-urgent", priorityComposite);
        KeywordFactory.addAliasEntry("-trivial", priorityComposite);
        KeywordFactory.addAliasEntry("-unimportant", priorityComposite);
    }

    private HashMap<String, ArrayList<String>> _priorityCompositeValues;
    private static final String CLASS_NAME = PriorityCompositeKeyword.class
            .getName();
        
    public PriorityCompositeKeyword(StandardKeyword type) {
        super(type);
    }

    public PriorityCompositeKeyword() {
        super(CompositeKeyword.PRIORITY);
    }

    @Override
    protected Keyword createKeyword() {
        return new PriorityCompositeKeyword();
    }

    @Override
    protected void initValues() {
        _priorityCompositeValues = new HashMap<String, ArrayList<String>>();
        _priorityCompositeValues.put("-urgent", getAliasValue("h"));
        _priorityCompositeValues.put("-trivial", getAliasValue("l"));
        _priorityCompositeValues.put("-unimportant", getAliasValue("l"));
    }

    private ArrayList<String> getAliasValue(String priorityValue) {
        ArrayList<String> substitute = new ArrayList<String>();
        substitute.add(SimpleKeyword.PRIORITY.getFormattedKeyword());
        substitute.add(priorityValue.toUpperCase());
        return substitute;
    }

    @Override
    public ArrayList<String> processKeyword(ArrayList<String> tokens,
            int currIndex, Argument argument) throws ParseException {

        String composite = getComposite(tokens.get(currIndex));
        if (_priorityCompositeValues.containsKey(composite)) {
            return replaceSimpleKeyword(tokens, currIndex, composite);
        } else {
            throw new ParseException("No Such priority composite keyword",
                    currIndex);
        }
    }

    private String getComposite(String keyword) {
        if (!keyword.startsWith(StandardKeyword.DELIMITER)) {
            return StandardKeyword.DELIMITER + keyword.toLowerCase();
        } else {
            return keyword.toLowerCase();
        }
    }

    private ArrayList<String> replaceSimpleKeyword(ArrayList<String> tokens,
            int currIndex, String composite) {
        LogHelper.log(CLASS_NAME, Level.INFO, tokens + " " +
                _priorityCompositeValues.get(composite));
        tokens.set(currIndex, null);
        tokens.addAll(currIndex + 1, _priorityCompositeValues.get(composite));
        return tokens;
    }

    @Override
    public Map<String, String> getKeywordValues() {

        HashMap<String, String> priorityValues = new HashMap<String, String>();
        ArrayList<String> valueArr;

        for (String key : _priorityCompositeValues.keySet()) {
            valueArr = _priorityCompositeValues.get(key);
            priorityValues.put(key, toString(valueArr));
        }
        return priorityValues;
    }

    private String toString(ArrayList<String> value) {
        StringBuilder strBuild = new StringBuilder();
        for (String token : value) {
            strBuild.append(token);
            strBuild.append(" ");
        }
        return strBuild.toString().trim();
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\PriorityCompositeKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\PriorityKeyword.java
	 */

public class PriorityKeyword extends Keyword {

    private static final int PREV = -1;
    private static final int NEXT = 1;
    private static final String INVALID_PRIORITY = "Invalid priority";
    private static final StandardKeyword PRIORITY = SimpleKeyword.PRIORITY;
    private static final String CLASS_NAME = PriorityKeyword.class.getName();

    private HashMap<String, String> _priorityValues;

    static {
        PriorityKeyword newPriority = new PriorityKeyword();
        KeywordFactory.addAliasEntry(PRIORITY.getFormattedKeyword(),
                newPriority);
    }

    public PriorityKeyword(StandardKeyword type) {
        super(type);
    }

    public PriorityKeyword() {
        this(PRIORITY);
    }

    @Override
    protected void initValues() {
        _priorityValues = new HashMap<String, String>();
        _priorityValues.put("low", "L");
        _priorityValues.put("l", "L");
        _priorityValues.put("medium", "M");
        _priorityValues.put("m", "M");
        _priorityValues.put("med", "M");
        _priorityValues.put("h", "H");
        _priorityValues.put("high", "H");
        _priorityValues.put("urgent", "H");
    }

    @Override
    /**
     * Process priority keyword. In this case, priority keyword will only process one word after/before
     * its keyword.
     */
    public ArrayList<String> processKeyword(ArrayList<String> tokens,
            int currIndex, Argument argument) throws ParseException {

        assert (tokens != null);

        String keyword = tokens.get(currIndex);
        LogHelper
                .log(CLASS_NAME, Level.INFO,
                        "Getting priority from: " + tokens.toString() +
                                " " +
                                currIndex);

        if (hasDelimiter(keyword)) {
            tokens = processPriorityValue(tokens, currIndex, NEXT, argument);
        } else if (isValidPriorityPrefix(tokens, currIndex)) {
            tokens = processPriorityValue(tokens, currIndex, PREV, argument);
        } else {
            tokens = processPriorityValue(tokens, currIndex, NEXT, argument);
        }

        return tokens;
    }

    private ArrayList<String> processPriorityValue(ArrayList<String> tokens,
            int currIndex, int nextIndex, Argument arguments)
            throws ParseException {
        int valueIndex = currIndex + nextIndex;
        String value = getValidValue(tokens, valueIndex); 
        if(value!=null) {
            updateArgument(value, arguments);
            tokens = updateTokens(tokens, currIndex, valueIndex);
        } else {
            throw new ParseException(INVALID_PRIORITY, 0);
        }
        return tokens;
    }
    
    private void updateArgument(String value, Argument arguments) throws ParseException {
        if(!hasExistingKeywordValue(arguments)){
            arguments.setKeywordValue(_type, value);
        } else {
            throw new ParseException(getExistingFlagErr(), 0);
        }
    }
    /**
     * Update the priority value and
     * 
     * @param tokens
     * @param keyIndex
     * @param valueIndex
     * @param key
     * @return
     */
    private ArrayList<String> updateTokens(ArrayList<String> tokens,
            int keyIndex, int valueIndex) {
        tokens.set(keyIndex, null);
        tokens.set(valueIndex, null);
        return tokens;
    }

    /**
     * Attempt to get the priority value from the tokens. If the value is
     * invalid, return null
     * 
     * @param tokens
     * @param prevIndex
     * @return the valid priority value or null if it's invalid
     */
    private String getValidValue(ArrayList<String> tokens, int valueIndex) {

        String key;

        try {
            key = tokens.get(valueIndex).toLowerCase();
        } catch (IndexOutOfBoundsException | NullPointerException e) {
            return null;
        }

        if (_priorityValues.containsKey(key)) {
            return _priorityValues.get(key);
        } else {
            return null;
        }
    }

    private boolean isValidPriorityPrefix(ArrayList<String> tokens,
            int currIndex) {
        int prevIndex = currIndex + PREV;
        if (prevIndex < 0) {
            return false;
        }

        return getValidValue(tokens, prevIndex) != null;
    }

    private boolean hasDelimiter(String keyword) {
        return keyword.startsWith(StandardKeyword.DELIMITER);
    }

    @Override
    protected Keyword createKeyword() {
        return new PriorityKeyword();
    }

    @Override
    public Map<String, String> getKeywordValues() {
        return _priorityValues;
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\PriorityKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\SimpleKeyword.java
	 */


public enum SimpleKeyword implements StandardKeyword{
    
    //Add your standard keywords here
    TASKID("TaskId"), 
    TO_TASK_TYPE("ToType"), 
    DESCRIPTION("Description"), 
    START("Start"), 
    END("End"), 
    RECURRING("Every"), 
    UNTIL("Until"), 
    PRIORITY("Priority"),
    ALL("All");
    
    private String _keyword;

    private SimpleKeyword(String keyword) {
        _keyword = keyword;
    }

    public String getKeyword() {
        return _keyword.toLowerCase();
    }

    public String getFilePrefix() {
        return _keyword;
    }
    
    public String getFormattedKeyword() {
        return DELIMITER + _keyword.toLowerCase();
    }
    
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\SimpleKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\StandardKeyword.java
	 */

public interface StandardKeyword {
    public static final String DELIMITER = "-";
    public static final String DELIMITER_ESCAPE =  "\u2010";
    public String getFilePrefix();
    public String getFormattedKeyword();
    public String getKeyword();
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\StandardKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\StartKeyword.java
	 */

public class StartKeyword extends Keyword {

    private LinkedHashMap<String, DateTime> _startValues;

    private static final int ONE_DAY = 1;
    private static final Integer ONE_YEAR = 1;
    private static final Integer ONE_MONTH = 1;
    private static final Integer ONE_WEEK = 7;

    private static final Integer NO_YEAR = 0;
    private static final Integer NO_MONTH = 0;
    private static final Integer NO_DAY = 0;
    private static final Integer NO_HOUR = 0;
    private static final Integer NO_MIN = 0;
    private static final Integer NO_SEC = 0;
    private static final Integer NO_NANO_SEC = 0;

    private static final int MONDAY = 0;
    private static final int TUESDAY = 1;
    private static final int WEDNESDAY = 2;
    private static final int THURSDAY = 3;
    private static final int FRIDAY = 4;
    private static final int SATURDAY = 5;
    private static final int SUNDAY = 6;

    static {
        StartKeyword startPrototype = new StartKeyword();
        KeywordFactory.addAliasEntry(SimpleKeyword.START.getFormattedKeyword(),
                startPrototype);
        KeywordFactory.addAliasEntry("-starting", startPrototype);
        KeywordFactory.addAliasEntry("-from", startPrototype);
    }

    protected static final String[] WEEK = { "mon", "tue", "wed", "thur",
            "fri", "sat", "sun" };

    protected String _defaultTime;

    private static final String CLASS_NAME = StartKeyword.class.getName();

    public StartKeyword(StandardKeyword type) {
        super(type);
    }

    public StartKeyword() {
        this(SimpleKeyword.START);
        _defaultTime = "000000";
    }

    @Override
    protected Keyword createKeyword() {
        return new StartKeyword();
    }

    @Override
    protected void initValues() {

        _startValues = new LinkedHashMap<String, DateTime>();
        DateTime today = DateTime.today(TimeZone.getDefault());

        // date-word
        _startValues.put("^today", today);
        _startValues.put("^tomorrow", today.plusDays(ONE_DAY));
        _startValues.put("^tmr", today.plusDays(ONE_DAY));
        _startValues.put("^tommorrow", today.plusDays(ONE_DAY));
        _startValues.put("^yesterday", today.minusDays(ONE_DAY));

        // this or next day
        _startValues.put("^(this\\s)?(monday|mon)", getWeekday(today, MONDAY));
        _startValues.put("^(this\\s)?(tuesday|tues|tue)",
                getWeekday(today, TUESDAY));
        _startValues.put("^(this\\s)?(wednesday|wed)",
                getWeekday(today, WEDNESDAY));
        _startValues.put("^(this\\s)?(thursday|thurs|thur)",
                getWeekday(today, THURSDAY));
        _startValues.put("^(this\\s)?(friday|fri)", getWeekday(today, FRIDAY));
        _startValues.put("^(this\\s)?(saturday|sat)",
                getWeekday(today, SATURDAY));
        _startValues.put("^(this\\s)?(sunday|sun)", getWeekday(today, SUNDAY));

        _startValues
                .put("^next\\s\\d*?\\s(days|weeks|months|years|day|week|month|year)",
                        null);

        _startValues.put("^next\\syear", today.plus(ONE_YEAR, NO_MONTH, NO_DAY,
                NO_HOUR, NO_MIN, NO_SEC, NO_NANO_SEC, DayOverflow.Spillover));
        _startValues.put("^next\\smonth", today.plus(NO_YEAR, ONE_MONTH,
                NO_DAY, NO_HOUR, NO_MIN, NO_SEC, NO_NANO_SEC,
                DayOverflow.Spillover));
        _startValues.put("^next\\sweek", today.plus(NO_YEAR, NO_MONTH,
                ONE_WEEK, NO_HOUR, NO_MIN, NO_SEC, NO_NANO_SEC,
                DayOverflow.Spillover));
        _startValues.put("^next\\sday", today.plus(NO_YEAR, NO_MONTH, ONE_DAY,
                NO_HOUR, NO_MIN, NO_SEC, NO_NANO_SEC, DayOverflow.Spillover));

        _startValues.put("^next\\s(monday|mon)", getNextWeekday(today, MONDAY));
        _startValues.put("^next\\s(tuesday|tue)",
                getNextWeekday(today, TUESDAY));
        _startValues.put("^next\\s(wednesday|wed)",
                getNextWeekday(today, WEDNESDAY));
        _startValues.put("^next\\s(thursday|thurs)",
                getNextWeekday(today, THURSDAY));
        _startValues.put("^next\\s(friday|fri)", getNextWeekday(today, FRIDAY));
        _startValues.put("^next\\s(saturday|sat)",
                getNextWeekday(today, SATURDAY));
        _startValues.put("^next\\s(sunday|sun)", getNextWeekday(today, SUNDAY));

    }

    private DateTime getNextWeekday(DateTime today, Integer nextWeekday) {
        today = today.plusDays(7);
        return getWeekday(today, nextWeekday);
    }

    private DateTime getWeekday(DateTime today, Integer nextWeekday) {

        int thisWeekday = today.getWeekDay() - 2;
        if (thisWeekday < 0) {
            thisWeekday = SUNDAY;
        }
        int daysInterval = nextWeekday - thisWeekday;
        return today.plusDays(daysInterval);
    }

    @Override
    public ArrayList<String> processKeyword(ArrayList<String> tokens,
            int currIndex, Argument argument) throws ParseException {

        String rawDate;
        String rawDateTime;
        String lookahead;
        String rawTime;

        // setup
        lookahead = getLookAhead(tokens, currIndex, LOOK_AHEAD_LIMIT);
        LogHelper.log(CLASS_NAME, Level.INFO, "Looking ahead: " + lookahead);

        if (hasJoinedDateTime(lookahead)) {
            String firstToken = getFirstToken(lookahead);
            String dateTime = getJointDateTime(firstToken);
            updateActualArgument(argument, dateTime);
            return nullifyTokens(tokens, currIndex, 1);
        } else {
            LogHelper.log(CLASS_NAME, Level.INFO,
                    lookahead + " is not joint datetime");
        }

        // time is the easiest to parse, so we shall try that
        rawTime = parseTimeFirst(lookahead);

        // time is not at first token, parse for the date
        if (rawTime == null) {
            LogHelper.log(CLASS_NAME, Level.INFO,
                    "No time at first token, Getting date first");
            rawDate = parseDateFirst(lookahead);
            rawTime = parseTimeFromRest(lookahead, rawDate);
            rawDateTime = getRawDateTime(rawDate, rawTime);
        } else {
            // parse the date from the rest
            LogHelper.log(CLASS_NAME, Level.INFO,
                    "Time found at first token, Getting date first");
            rawDate = parseDateFromRest(lookahead, rawTime);
            rawDateTime = getRawDateTime(rawTime, rawDate);
        }

        checkValidDateTime(rawDate, rawTime);

        int argLimit = getArgLimit(rawDateTime);
        String time = getMilitaryTime(rawTime);
        String date = getMilitaryDate(rawDate);
        updateArgument(argument, date, time);
        return nullifyTokens(tokens, currIndex, argLimit);
    }

    private String getJointDateTime(String dateTime) throws ParseException {
        dateTime = dateTime.trim();
        Date jointDateTime = DateUtil.parse(dateTime);
        SimpleDateFormat milDateTime = new SimpleDateFormat(
                DateUtil.MILITARY_DATE_FORMAT + DateUtil.MILITARY_TIME_FORMAT);
        return milDateTime.format(jointDateTime);
    }

    private boolean hasJoinedDateTime(String lookahead) {
        String firstToken = getFirstToken(lookahead);
        try {
            DateUtil.parse(firstToken, "ddMMyyyyHHmm");
            return true;
        } catch (ParseException e) {
            // FALLTHROUGH
        }
        try {
            DateUtil.parse(firstToken, "ddMMyyyyHHmmss");
            return true;
        } catch (ParseException e) {
            // FALLTHROUGH
        }
        return false;
    }

    private void checkValidDateTime(String rawDate, String rawTime)
            throws ParseException {
        if (rawDate == null && rawTime == null) {
            throw new ParseException("Please give a valid date and time", 0);
        }
    }

    protected ArrayList<String> nullifyTokens(ArrayList<String> tokens,
            int currIndex, int argLimit) {
        argLimit = currIndex + 1 + argLimit;
        for (int i = currIndex + 1; i < argLimit; i++) {
            tokens.set(i, null);
        }
        return tokens;
    }

    protected void updateArgument(Argument argument, String date, String time) throws ParseException{

        assert (argument != null);

        if (date == null) {
            DateTime today = DateTime.today(TimeZone.getDefault());
            date = today.format(DateUtil.MILITARY_DATE_FORMAT.toUpperCase());
        }
        if (time == null) {
            LogHelper.log(CLASS_NAME, Level.INFO, _defaultTime);
            time = _defaultTime;
        }

        String dateTime = date + time;
        updateActualArgument(argument, dateTime);
    }

    private void updateActualArgument(Argument argument, String dateTime) throws ParseException {
        
        if(!hasExistingKeywordValue(argument)){
            argument.setKeywordValue(_type, dateTime.trim());
        } else {
            throw new ParseException(getExistingFlagErr(), 0);
        }
    }

    protected String getMilitaryDate(String rawDate) throws ParseException {
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Getting military date: " + rawDate);

        if (rawDate == null) {
            return null;
        }

        if (hasDatePhrase(rawDate)) {
            rawDate = convertDatePharseToDate(rawDate);
        } else if (DateUtil.isPartialDate(rawDate)) {
            rawDate = DateUtil.getDateFromPartial(rawDate);
        }

        return DateUtil.getMilitaryDate(rawDate);
    }

    protected String convertDatePharseToDate(String rawDate) {

        Pattern phrasePattern;
        Matcher phraseMatch;

        DateTime converted = null;
        String properPhrase = null;
        boolean isParseable = false;

        for (String regex : _startValues.keySet()) {
            phrasePattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
            phraseMatch = phrasePattern.matcher(rawDate);
            if (phraseMatch.find()) {
                isParseable = true;
                properPhrase = phraseMatch.group();
                converted = _startValues.get(regex);
                break;
            }
        }

        if (isParseable && converted == null) {
            return processDateWithValue(properPhrase);
        } else if (converted != null) {
            return converted
                    .format(DateUtil.MILITARY_DATE_FORMAT.toUpperCase());
        } else {
            return null;
        }
    }

    private String processDateWithValue(String properPhrase) {

        String valueRegex = "\\s\\d*\\s(day|days|month|months|year|years|week|weeks)";

        Pattern valuePattern = Pattern.compile(valueRegex,
                Pattern.CASE_INSENSITIVE);
        Matcher valueMatcher = valuePattern.matcher(properPhrase);

        String dateValue = null;

        if (valueMatcher.find()) {
            dateValue = valueMatcher.group();
        } else {
            return null;
        }
        LogHelper.log(CLASS_NAME, Level.INFO,
                "From date with value: " + dateValue);

        String[] dateValueTokens = dateValue.trim().split(" ");
        int advancedValue = Integer.parseInt(dateValueTokens[0]);
        String dateType = dateValueTokens[1].toLowerCase();

        DateTime advancedDate = DateTime.today(TimeZone.getDefault());

        if (dateType.startsWith("day")) {
            advancedDate = advancedDate.plus(NO_YEAR, NO_MONTH, advancedValue,
                    NO_HOUR, NO_MIN, NO_SEC, NO_NANO_SEC,
                    DateTime.DayOverflow.Spillover);
        } else if (dateType.startsWith("month")) {
            advancedDate = advancedDate.plus(NO_YEAR, advancedValue, NO_DAY,
                    NO_HOUR, NO_MIN, NO_SEC, NO_NANO_SEC,
                    DateTime.DayOverflow.Spillover);
        } else if (dateType.startsWith("week")) {
            advancedDate = advancedDate.plus(NO_YEAR, NO_MONTH,
                    advancedValue * 7, NO_HOUR, NO_MIN, NO_SEC, NO_NANO_SEC,
                    DateTime.DayOverflow.Spillover);
        } else if (dateType.startsWith("year")) {
            advancedDate = advancedDate.plus(advancedValue, NO_MONTH, NO_DAY,
                    NO_HOUR, NO_MIN, NO_SEC, NO_NANO_SEC,
                    DateTime.DayOverflow.Spillover);
        } else {
            return null;
        }

        return advancedDate.format(DateUtil.MILITARY_DATE_FORMAT.toUpperCase());
    }

    private String getMilitaryTime(String rawTime) throws ParseException {
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Getting military time: " + rawTime);

        if (rawTime == null) {
            return null;
        }
        return DateUtil.getMilitaryTime(rawTime);
    }

    protected int getArgLimit(String rawDateTime) {
        String[] rawDateTimeTokens = rawDateTime.split(" ");
        return rawDateTimeTokens.length;
    }

    private String parseDateFromRest(String lookahead, String rawTime)
            throws ParseException {
        String lookaheadRest = getLookaheadRest(lookahead, rawTime);
        return parseDateFirst(lookaheadRest);
    }

    private String parseTimeFromRest(String lookahead, String rawDate)
            throws ParseException {
        LogHelper.log(CLASS_NAME, Level.INFO, "Lookahead: " + lookahead +
                " rawDate: " +
                rawDate);
        String lookaheadRest = getLookaheadRest(lookahead, rawDate);
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Trimmed Lookahead: " + lookaheadRest);
        return parseTimeFirst(lookaheadRest);
    }

    private String getLookaheadRest(String lookahead, String rawDateOrTime) {

        if (rawDateOrTime == null) {
            return lookahead;
        }

        int rawLength = rawDateOrTime.length();
        return lookahead.substring(rawLength).trim();
    }

    protected String parseDateFirst(String lookahead) throws ParseException {
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Getting date first: " + lookahead + "|");
        String dateCandidate = getFirstToken(lookahead);
        LogHelper.log(CLASS_NAME, Level.INFO, "Candidate: " + dateCandidate +
                "|");

        if (DateUtil.isDate(dateCandidate)) {
            return dateCandidate;
        } else if (hasDatePhrase(lookahead)) {
            return getDatePhrase(lookahead);
        } else if (DateUtil.isPartialDate(dateCandidate)) {
            return dateCandidate;
        }

        return null;
    }

    protected boolean hasDatePhrase(String lookahead) {
        return getDatePhrase(lookahead) != null;
    }

    protected String getDatePhrase(String lookahead) {
        Pattern phraseRegex;
        Matcher phraseMatcher;

        for (String regex : _startValues.keySet()) {
            phraseRegex = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
            phraseMatcher = phraseRegex.matcher(lookahead);
            if (phraseMatcher.find()) {
                return phraseMatcher.group();
            }
        }

        return null;
    }

    private String parseTimeFirst(String lookahead) throws ParseException {
        LogHelper.log(CLASS_NAME, Level.INFO,
                "parseTimeFirst lookahead: " + lookahead + "|");
        String firstToken = getFirstToken(lookahead);
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Getting time first token: " + firstToken + "|");

        if (DateUtil.isTime(firstToken)) {
            return firstToken;
        } else {
            return null;
        }
    }

    private String getRawDateTime(String firstSeg, String secSeg) {
        if (firstSeg == null) {
            firstSeg = "";
        }
        if (secSeg == null) {
            secSeg = "";
        }
        String dateTimePhrase = firstSeg + " " + secSeg;
        return dateTimePhrase.trim();
    }

    private String getFirstToken(String lookahead) {
        int firstDelimit = lookahead.trim().indexOf(" ");
        if (firstDelimit == -1) {
            return lookahead;
        }
        String firstToken = lookahead.substring(0, firstDelimit);
        return firstToken;
    }

    @Override
    public Map<String, String> getKeywordValues() {
        LinkedHashMap<String, String> dateStrings = new LinkedHashMap<String, String>();

        for (String key : _startValues.keySet()) {
            String value = _startValues.get(key).format("DDMMYYYYHHMMSS");
            dateStrings.put(key, value);
        }

        return dateStrings;
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\StartKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\TaskIdKeyword.java
	 */

public class TaskIdKeyword extends Keyword {

    protected HashMap<String, String> _taskTypeValues;
    protected String _taskRegex;
    protected String _idRegex = "\\d+";

    private static final int TASK_ID_LOOKAHEAD = 2;
    private static final String CLASS_NAME = TaskIdKeyword.class.getName();

    static {
        TaskIdKeyword newTaskId = new TaskIdKeyword(SimpleKeyword.TASKID);
        KeywordFactory.addAliasEntry("-taskid", newTaskId);
    }

    public TaskIdKeyword(StandardKeyword type) {
        super(type);
    }

    public TaskIdKeyword() {
        this(SimpleKeyword.TASKID);
        initValues();
    }

    @Override
    protected Keyword createKeyword() {
        return new TaskIdKeyword();
    }

    @Override
    protected void initValues() {

        _taskTypeValues = new HashMap<String, String>();

        _taskTypeValues.put(TaskType.EVENT.getType(), TaskType.EVENT.getType());
        _taskTypeValues.put("e", TaskType.EVENT.getType());
        _taskTypeValues.put("events", TaskType.EVENT.getType());
        _taskTypeValues.put("appointment", TaskType.EVENT.getType());
        _taskTypeValues.put("appt", TaskType.EVENT.getType());
        _taskTypeValues.put("appts", TaskType.EVENT.getType());

        _taskTypeValues.put(TaskType.TODO.getType(), TaskType.TODO.getType());
        _taskTypeValues.put("td", TaskType.TODO.getType());
        _taskTypeValues.put("to-do", TaskType.TODO.getType());
        _taskTypeValues.put("todos", TaskType.TODO.getType());
        _taskTypeValues.put("task", TaskType.TODO.getType());
        _taskTypeValues.put("tasks", TaskType.TODO.getType());

        _taskTypeValues.put(TaskType.DEADLINE.getType(),
                TaskType.DEADLINE.getType());
        _taskTypeValues.put("d", TaskType.DEADLINE.getType());
        _taskTypeValues.put("deadlines", TaskType.DEADLINE.getType());
        _taskTypeValues.put("cutoff", TaskType.DEADLINE.getType());
        _taskTypeValues.put("cutoffs", TaskType.DEADLINE.getType());

        StringBuilder taskTypeAlias = new StringBuilder();

        for (String key : _taskTypeValues.keySet()) {
            taskTypeAlias.append(key);
            taskTypeAlias.append("|");
        }
        String regex = "^(%1$s)(\\s)?";
        taskTypeAlias = taskTypeAlias.deleteCharAt(taskTypeAlias.length() - 1);
        _taskRegex = String.format(regex, taskTypeAlias.toString());
    }

    @Override
    public ArrayList<String> processKeyword(ArrayList<String> tokens,
            int currIndex, Argument argument) throws ParseException {

        String rawTaskId, taskId, lookahead;

        lookahead = getLookAhead(tokens, currIndex, TASK_ID_LOOKAHEAD);
        rawTaskId = extractTaskId(lookahead);
        tokens = nullifyTokens(rawTaskId, tokens, currIndex);
        taskId = processTaskId(rawTaskId);
        updateArgument(taskId, argument);

        return tokens;
    }

    private String extractTaskId(String lookahead) {
        String allRegex = _taskRegex + _idRegex;
        Pattern rawTaskIdPattern = Pattern.compile(allRegex,
                Pattern.CASE_INSENSITIVE);
        Matcher rawTaskIdMatcher = rawTaskIdPattern.matcher(lookahead);

        if (rawTaskIdMatcher.find()) {
            return rawTaskIdMatcher.group();
        }

        return null;
    }

    protected ArrayList<String> nullifyTokens(String rawTaskId,
            ArrayList<String> tokens, Integer currIndex) {

        if (rawTaskId == null) {
            return tokens;
        }

        int upperLimit = rawTaskId.split(" ").length + currIndex;
        for (int i = currIndex; i < tokens.size() && i <= upperLimit; i++) {
            tokens.set(i, null);
        }

        return tokens;
    }

    private String processTaskId(String rawTaskId) {
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Processing raw task id: " + rawTaskId);

        if (rawTaskId == null) {
            return null;
        }

        rawTaskId = rawTaskId.trim();
        Pattern taskPattern = Pattern.compile(_taskRegex,
                Pattern.CASE_INSENSITIVE);
        Matcher taskMatcher = taskPattern.matcher(rawTaskId);

        Pattern idPattern = Pattern.compile(_idRegex, Pattern.CASE_INSENSITIVE);
        Matcher idMatcher = idPattern.matcher(rawTaskId);

        String taskType;
        String id;

        if (taskMatcher.find()) {
            taskType = taskMatcher.group().trim();
            taskType = _taskTypeValues.get(taskType);
        } else {
            return null;
        }

        if (idMatcher.find()) {
            id = idMatcher.group().trim();
        } else {
            return null;
        }

        return taskType + " " + id;

    }

    protected void updateArgument(String taskId, Argument argument)
            throws ParseException {

        if (taskId == null) {
            throw new ParseException("Not a valid task id", 0);
        } else if(hasExistingKeywordValue(argument)) {
            throw new ParseException(getExistingFlagErr(), 0);
        }
        argument.setKeywordValue(_type, taskId);
    }

    @Override
    public Map<String, String> getKeywordValues() {
        return _taskTypeValues;
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\TaskIdKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\ToTypeKeyword.java
	 */

public class ToTypeKeyword extends TaskIdKeyword {
    
    static {
        ToTypeKeyword toType = new ToTypeKeyword(SimpleKeyword.TO_TASK_TYPE);
        KeywordFactory.addAliasEntry("-totype", toType);
        KeywordFactory.addAliasEntry("-changeto", toType);
        KeywordFactory.addAliasEntry("-totask", toType);
    }
    
    private static final int TO_TYPE_LOOKAHEAD = 1;
    
    public ToTypeKeyword(StandardKeyword type) {
        super(type);
    }
    
    public ToTypeKeyword() {
        this(SimpleKeyword.TO_TASK_TYPE);
        initValues();
    }
    
    @Override
    public ArrayList<String> processKeyword(ArrayList<String> tokens,
                                            int currIndex, Argument argument) throws ParseException {
        
        String lookahead = getLookAhead(tokens, currIndex, TO_TYPE_LOOKAHEAD);
        String taskType = processLookahead(lookahead);
        updateArgument(taskType, argument);
        return nullifyTokens(lookahead, tokens, currIndex);
    }
    
    @Override
    protected Keyword createKeyword() {
        return new ToTypeKeyword();
    }
    
    
    private String processLookahead(String lookahead) throws ParseException{
        
        if (lookahead==null) {
            throw new ParseException("Invalid task type", 0);
        }
        
        Pattern taskTypePattern = Pattern.compile(_taskRegex, Pattern.CASE_INSENSITIVE);
        Matcher taskTypeMatcher = taskTypePattern.matcher(lookahead);
        String taskType;
        if (taskTypeMatcher.find()) {
            taskType = taskTypeMatcher.group();
            taskType = _taskTypeValues.get(taskType);
        } else {
            throw new ParseException("Invalid task type", 0);
        }
        
        return taskType;
    }
    
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\ToTypeKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\UntilKeyword.java
	 */

public class UntilKeyword extends EndKeyword {

    static {
        UntilKeyword untilKeyword = new UntilKeyword();
        KeywordFactory.addAliasEntry("-until", untilKeyword);
    }

    public UntilKeyword(StandardKeyword type) {
        super(type);
    }

    public UntilKeyword() {
        this(SimpleKeyword.UNTIL);
        _defaultTime = "235959";
    }

    @Override
    protected Keyword createKeyword() {
        return new UntilKeyword();
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\commandcontroller\keyword\UntilKeyword.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\controller\TaskFilterManager.java
	 */

public class TaskFilterManager {

    private static final boolean IS_END = false;
    private static final boolean IS_START = true;

    public static final int ONE_SECOND = 1000;
    public static final int ONE_MINUTE = ONE_SECOND * 60;
    public static final int ONE_HOUR = ONE_MINUTE * 60;
    public static final int ONE_DAY = ONE_HOUR * 24;

    private static final int HOUR = 0;
    private static final int MIN = 1;
    private static final int SEC = 2;
    private static final int START_TIME[] = { 0, 0, 0 };
    private static final int END_TIME[] = { 23, 59, 59 };
    private static final int START = 0;
    private static final int END = 1;
    private static final String CLASS_NAME = TaskFilterManager.class.getName();

    private TaskDataManager _taskStore;

    public TaskFilterManager(TaskDataManager taskStore) {
        _taskStore = taskStore;
    }

    /**
     * Filter the tasks based on its criteria
     * 
     * @param param a FilterParameter object that represents the criteria
     * @return An arraylist of tasks that satisfied the task. Empty if there's
     * none
     */
    public HashMap<TaskType, ArrayList<Task<?>>> filterTask(
            FilterParameter filters) {

        // GuardClause
        assert (filters != null);
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Filtering tasks with " + filters.getFilters());

        HashMap<TaskType, ArrayList<Task<?>>> result = new HashMap<TaskType, ArrayList<Task<?>>>();

        // All tasks are already sorted. This is added for user's brevity
        filters.remove(FilterType.PRIORITY);

        // Based on the task status
        if (filters.contains(FilterType.COMPLETE)) {

            filters.remove(FilterType.COMPLETE);
            result = filterCompletedTasks(filters);

        } else if (filters.contains(FilterType.COMPLETE_PLUS)) {

            filters.remove(FilterType.COMPLETE_PLUS);
            result = combineCompUncompTasks(filters);

        } else {

            if (filters.hasNoTaskTypes()) {
                filters = fillNoTasksFilter(filters);
            }

            result = filterUncompletedTasks(filters);

        }

        return result;

    }

    private HashMap<TaskType, ArrayList<Task<?>>> combineCompUncompTasks(
            FilterParameter filters) {

        HashMap<TaskType, ArrayList<Task<?>>> completedTasks;
        HashMap<TaskType, ArrayList<Task<?>>> uncompletedTasks;
        HashMap<TaskType, ArrayList<Task<?>>> result;
        completedTasks = filterCompletedTasks(filters);
        uncompletedTasks = filterUncompletedTasks(filters);
        result = new HashMap<TaskType, ArrayList<Task<?>>>();

        for (TaskType type : uncompletedTasks.keySet()) {
            ArrayList<Task<?>> currentTasks = uncompletedTasks.get(type);
            currentTasks.addAll(completedTasks.get(type));
            // Collections.sort(currentTasks, new GenericTaskComparator);
            result.put(type, currentTasks);
        }

        return result;
    }

    private HashMap<TaskType, ArrayList<Task<?>>> filterUncompletedTasks(
            FilterParameter filters) {

        HashMap<TaskType, ArrayList<Task<?>>> result = new HashMap<TaskType, ArrayList<Task<?>>>();
        ArrayList<Task<?>> neededTasks;

        if (filters.hasNoTaskTypes()) {
            filters = fillNoTasksFilter(filters);
        }

        if (filters.contains(FilterType.DEADLINE)) {

            LogHelper.log(CLASS_NAME, Level.INFO,
                    "Getting uncompleted deadlines");
            neededTasks = getTasks(_taskStore.getUncompletedDeadlineTasks());
            result.put(TaskType.DEADLINE, neededTasks);
        }

        if (filters.contains(FilterType.TODO)) {

            LogHelper.log(CLASS_NAME, Level.INFO, "Getting uncompleted todos");
            neededTasks = getTasks(_taskStore.getUncompletedTodoTasks());
            result.put(TaskType.TODO, neededTasks);
        }

        if (filters.contains(FilterType.EVENT)) {

            LogHelper.log(CLASS_NAME, Level.INFO, "Getting uncompleted events");
            neededTasks = getTasks(_taskStore.getUncompletedEventTasks());
            result.put(TaskType.EVENT, neededTasks);
        }

        if (hasDateRange(filters)) {
            // Note that the individual type will mix up

            LogHelper.log(CLASS_NAME, Level.INFO,
                    "Filtering uncompleted tasks by date range");
            result = filterResultsByDate(TaskType.DEADLINE, result, filters);
            result = filterResultsByDate(TaskType.EVENT, result, filters);
        }

        return result;
    }

    /**
     * 
     * Filter the result further by filter's date range. If the type does not
     * exist in the result, nothing will change
     * 
     * @param currType
     * @param result
     * @param filters
     * @return
     */
    private HashMap<TaskType, ArrayList<Task<?>>> filterResultsByDate(
            TaskType currType, HashMap<TaskType, ArrayList<Task<?>>> result,
            FilterParameter filters) {

        assert (result != null);
        assert (filters != null);

        ArrayList<Task<?>> filteredResult;
        ArrayList<Task<?>> timedTasks;

        LogHelper.log(CLASS_NAME, Level.INFO,
                "Checking to see it contains " + currType);
        if (result.containsKey(currType)) {

            LogHelper.log(CLASS_NAME, Level.INFO, "Found " + currType +
                    " filtering date.");
            timedTasks = result.get(currType);
            filteredResult = filterByDate(timedTasks, filters);
            result.put(currType, filteredResult);
        }

        return result;
    }

    /**
     * Filter each task by its date.
     * 
     * @param result
     * @param filters
     * @param start Starting date
     * @param end ending date
     * @return The pruned arraylist
     */
    private ArrayList<Task<?>> filterByDate(ArrayList<Task<?>> result,
            FilterParameter filters) {

        ArrayList<Task<?>> filteredResult = new ArrayList<Task<?>>();
        Date start = filters.getStart();
        Date end = filters.getEnd();
        boolean hasStartTime = filters.hasStartTime();
        boolean hasEndTime = filters.hasEndTime();

        if (!hasStartTime) {

            LogHelper.log(CLASS_NAME, Level.INFO,
                    "Writing date to appropriate format for START: " + start);
            start = sanitiseDate(start, IS_START);
        }

        if (!hasEndTime) {

            LogHelper.log(CLASS_NAME, Level.INFO,
                    "Writing date to appropriate format for END: " + end);
            end = sanitiseDate(end, IS_END);
        }

        LogHelper.log(CLASS_NAME, Level.INFO, "Date returned START: " + start +
                "and END: " +
                end);

        // Only EventTask / DeadlineTask will be checked
        for (Task<?> task : result) {
            assert (!(task instanceof TodoTask));

            LogHelper.log(CLASS_NAME, Level.INFO, "START: " + start +
                    " END: " +
                    end +
                    "Task: " +
                    task);
            if (isInDateRange(task, start, end)) {

                LogHelper.log(CLASS_NAME, Level.INFO, "Within range");
                filteredResult.add(task);
            } else {

                LogHelper.log(CLASS_NAME, Level.INFO, "Not within range");
            }
        }

        return filteredResult;
    }

    /**
     * Check to see whether is it in date range
     * 
     * @param task
     * @param start
     * @param end
     * @param hasTime
     * @return
     */
    private boolean isInDateRange(Task<?> task, Date start, Date end) {

        // Guard clause
        assert (task instanceof EventTask || task instanceof DeadlineTask);
        assert (start != null || end != null);

        Date[] targetDate = new Date[2];

        if (task instanceof EventTask) {
            targetDate[START] = ((EventTask) task).getStartTime();
            targetDate[END] = ((EventTask) task).getEndTime();
        } else {
            targetDate[START] = targetDate[END] = ((DeadlineTask) task)
                    .getEndTime();
        }

        if (start != null && end != null) {

            LogHelper.log(CLASS_NAME, Level.INFO,
                    "StartTargetDate: " + targetDate[START].toString() +
                            "\n" +
                            "EndTargetDate: " +
                            targetDate[END].toString() +
                            "\n" +
                            "Start: " +
                            start.toString() +
                            "\n" +
                            "End: " +
                            end.toString());

            return !(end.before(targetDate[START]) || start
                    .after(targetDate[END]));

        } else if (start != null) {
            return isTargetAfterOrEqual(targetDate[END], start);
        } else {
            return isTargetBeforeOrEqual(targetDate[START], end);
        }
    }

    private boolean isTargetBeforeOrEqual(Date targetDate, Date end) {
        return targetDate.before(end) || targetDate.equals(end);
    }

    private boolean isTargetAfterOrEqual(Date targetDate, Date start) {
        return targetDate.after(start) || targetDate.equals(start);
    }

    /**
     * Sanitise the date based on its start or end.
     * 
     * @param date The date in question
     * @param isStart Is it a start date or end
     * @return If it's start, set to 23:59:59 of yesterday's start date If it's
     * end, set to 23:59 of end date.
     */
    private Date sanitiseDate(Date date, boolean isStart) {

        // Guard clause
        if (date == null) {
            return null;
        }

        Calendar currDate = Calendar.getInstance();
        currDate.setTime(date);

        if (isStart) {
            currDate.set(currDate.get(Calendar.YEAR),
                    currDate.get(Calendar.MONTH), currDate.get(Calendar.DATE),
                    START_TIME[HOUR], START_TIME[MIN], START_TIME[SEC]);
        } else {
            currDate.set(currDate.get(Calendar.YEAR),
                    currDate.get(Calendar.MONTH), currDate.get(Calendar.DATE),
                    END_TIME[HOUR], END_TIME[MIN], END_TIME[SEC]);
        }

        return currDate.getTime();
    }

    /**
     * Check to see if there is date range
     * 
     * @param filters
     * @return
     */
    private boolean hasDateRange(FilterParameter filters) {
        return filters.contains(FilterType.START) || filters
                .contains(FilterType.END);
    }

    private HashMap<TaskType, ArrayList<Task<?>>> filterCompletedTasks(
            FilterParameter filters) {

        HashMap<TaskType, ArrayList<Task<?>>> result = new HashMap<TaskType, ArrayList<Task<?>>>();
        ArrayList<Task<?>> neededTasks;

        if (filters.hasNoTaskTypes()) {
            filters = fillNoTasksFilter(filters);
        }

        if (filters.contains(FilterType.DEADLINE)) {

            LogHelper
                    .log(CLASS_NAME, Level.INFO, "Getting completed deadlines");
            neededTasks = getTasks(_taskStore.getCompletedDeadlineTasks());
            result.put(TaskType.DEADLINE, neededTasks);
        }

        if (filters.contains(FilterType.TODO)) {

            LogHelper.log(CLASS_NAME, Level.INFO, "Getting completed todos");
            neededTasks = getTasks(_taskStore.getCompletedTodoTasks());
            result.put(TaskType.TODO, neededTasks);
        }

        if (filters.contains(FilterType.EVENT)) {

            LogHelper.log(CLASS_NAME, Level.INFO, "Getting completed events");
            neededTasks = getTasks(_taskStore.getCompletedEventTasks());
            result.put(TaskType.EVENT, neededTasks);
        }

        if (hasDateRange(filters)) {
            // Note that the individual type will mix up

            LogHelper.log(CLASS_NAME, Level.INFO,
                    "Filtering completed tasks by date range");
            result = filterResultsByDate(TaskType.DEADLINE, result, filters);
            result = filterResultsByDate(TaskType.EVENT, result, filters);
        }

        return result;

    }

    /**
     * Convert the Tasks TreeSet into an arraylist. Note: All tasks set must be
     * under the same superclass and iterable/has a way to iterate its elements.
     * 
     * @param taskSet The set of specific task type
     * @return The converted arraylist
     */
    private ArrayList<Task<?>> getTasks(SortedSet<? extends Task<?>> taskSet) {

        Iterator<? extends Task<?>> tasksIter = taskSet.iterator();
        ArrayList<Task<?>> tasks = new ArrayList<Task<?>>();

        while (tasksIter.hasNext()) {
            tasks.add(tasksIter.next());
        }
        return tasks;
    }

    /**
     * If empty filters, put in every tasktype filters.
     * 
     * @return a few filter that contains every tasktype filters
     */
    private FilterParameter fillNoTasksFilter(FilterParameter existingFilter) {

        LogHelper.log(CLASS_NAME, Level.INFO,
                "Add default filter types: deadlines, events and todos");

        ArrayList<FilterType> newFilters = existingFilter.getFilters();

        newFilters.add(FilterType.DEADLINE);
        newFilters.add(FilterType.EVENT);
        newFilters.add(FilterType.TODO);

        return existingFilter;
    }

    /**
     * Search for tasks based on its keywords.
     * 
     * @param param a SearchParameter object that represents the keywords used
     * @return An arraylist of task that satisfied the keywords. Empty if
     * there's none.
     */
    public HashMap<TaskType, ArrayList<Task<?>>> searchTasks(
            SearchParameter param) {

        ArrayList<String> keywords = param.getKeywords();
        HashMap<TaskType, ArrayList<Task<?>>> result;
        result = new HashMap<TaskType, ArrayList<Task<?>>>();

        // Guard clause
        assert (param != null);
        if (keywords.isEmpty()) {
            return result;
        }

        LogHelper.log(CLASS_NAME, Level.INFO, "Getting task set");

        FilterParameter allTypes = fillNoTasksFilter(new FilterParameter());
        HashMap<TaskType, ArrayList<Task<?>>> uncompletedTasks;
        uncompletedTasks = filterUncompletedTasks(allTypes);

        for (TaskType type : uncompletedTasks.keySet()) {

            LogHelper.log(CLASS_NAME, Level.INFO,
                    "Searching for " + param.getKeywords());

            ArrayList<Task<?>> specificResult = new ArrayList<Task<?>>();
            for (Task<?> task : uncompletedTasks.get(type)) {

                LogHelper.log(CLASS_NAME, Level.INFO, "Searching by " + type +
                        " in " +
                        task);
                if (searchKeywords(task, keywords)) {

                    LogHelper.log(CLASS_NAME, Level.INFO, "Found");
                    specificResult.add(task);
                } else {

                    LogHelper.log(CLASS_NAME, Level.INFO, "Not found");
                }
            }

            LogHelper.log(CLASS_NAME, Level.INFO, "Finished with " + type);
            result.put(type, specificResult);

        }

        return result;
    }

    private boolean searchKeywords(Task<?> task, ArrayList<String> keywords) {

        String description = task.getDescription().toLowerCase();

        for (String keyword : keywords) {
            if (description.contains(keyword.toLowerCase())) {
                return true;
            }
        }

        return false;
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\controller\TaskFilterManager.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\model\FilterType.java
	 */


public enum FilterType {
	DEADLINE("deadline"),
	TODO("todo"),
	EVENT("event"),
	COMPLETE("complete"),
	COMPLETE_PLUS("+complete"),
	PRIORITY("priority"), 
	START("start"), 
	END("end");
		
	private String _type;
		
	private FilterType(String type) { 
		_type = type;
	}
		
	public String getType() {
		return _type;
	}
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\model\FilterType.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\model\parameter\FilterParameter.java
	 */


public class FilterParameter {

    private ArrayList<FilterType> _filters;
    private Date _start;
    private Date _end;
    private boolean _hasStartTime;
    private boolean _hasEndTime;

    public FilterParameter(ArrayList<String> newFilters) {
        this(newFilters, null, null, false);
    }

    public FilterParameter() {
        _filters = new ArrayList<FilterType>();
        _start = null;
        _end = null;
    }

    /**
     * Create a new filer parameter with
     * 
     * @param newFilters
     * @param start
     * @param end
     */
    public FilterParameter(ArrayList<String> newFilters, Date start, Date end,
            boolean hasTime) {
        this(newFilters, start, end, hasTime, hasTime);
    }

    /**
     * Create a new filer parameter with
     * 
     * @param newFilters
     * @param start
     * @param end
     */
    public FilterParameter(ArrayList<String> newFilters, Date start, Date end,
            boolean hasStartTime, boolean hasEndTime) {

        _filters = getFilterTypes(newFilters);
        setStart(start);
        setEnd(end);
        _hasStartTime = hasStartTime;
        _hasEndTime = hasEndTime;
    }

    public ArrayList<FilterType> getFilters() {
        return _filters;
    }

    /**
     * Convert the argument String into their appropriate types
     * 
     * @param filters
     * @return Arraylist of FilterType
     */
    private ArrayList<FilterType> getFilterTypes(ArrayList<String> rawFilters) {

        ArrayList<FilterType> filters = new ArrayList<FilterType>();

        for (FilterType filterType : FilterType.values()) {
            if (rawFilters.contains(filterType.getType())) {
                filters.add(filterType);
            }
        }
        return filters;
    }

    public Date getStart() {
        return _start;
    }

    public void setStart(Date start) {

        boolean hasStartFilter = _filters.contains(FilterType.START);
        _start = start;

        if (start != null && !hasStartFilter) {
            _filters.add(FilterType.START);
        } else if (hasStartFilter) {
            _filters.remove(FilterType.START);
        }
    }

    public Date getEnd() {
        return _end;
    }

    public void setEnd(Date end) {

        boolean hasEndFilter = _filters.contains(FilterType.END);
        _end = end;

        if (end != null && !hasEndFilter) {
            _filters.add(FilterType.END);
        } else if (hasEndFilter) {
            _filters.remove(FilterType.END);
        }
    }

    public boolean hasTime() {
        return _hasStartTime && _hasEndTime;
    }

    public boolean hasStartTime() {
        return _hasStartTime;
    }

    public boolean hasEndTime() {
        return _hasEndTime;
    }

    public void setStartTime(boolean hasStartTime) {
        _hasStartTime = hasStartTime;
    }

    public void setEndTime(boolean hasEndTime) {
        _hasEndTime = hasEndTime;
    }

    public boolean contains(FilterType type) {
        return _filters.contains(type);
    }

    public boolean remove(FilterType type) {
        return _filters.remove(type);
    }

    public void addFilter(FilterType type) {
        _filters.add(type);
    }

    public boolean hasNoTaskTypes() {
        return !(_filters.contains(FilterType.EVENT) || _filters
                .contains(FilterType.DEADLINE) || _filters
                    .contains(FilterType.TODO));
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\model\parameter\FilterParameter.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\model\parameter\SearchParameter.java
	 */


public class SearchParameter {

	private ArrayList<String> _keywords;

	public SearchParameter(ArrayList<String> newKeywords) {
		_keywords = newKeywords;
	}

	public SearchParameter() {
		_keywords = new ArrayList<String>();
	}

	public ArrayList<String> getKeywords() {
		return _keywords;
	}
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\model\parameter\SearchParameter.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\utils\DateUtil.java
	 */

    private static final LinkedHashMap<String, String> TIME_FORMAT_REGEX = new LinkedHashMap<String, String>() {
        private static final long serialVersionUID = 3L;
        {
            // Military time
            put("^\\d{4}$", "HHmm");

            // HH AM/PM
            put("^\\d{1}(am|pm|AM|PM){1}$", "ha");
            put("^\\d{1,2}(am|pm|AM|PM){1}$", "hha");
            // HH no AM/PM
            put("^\\d{1}$", "H");
            put("^\\d{1,2}$", "HH");

            // HH:MM:SS AM/PM
            put("^\\d{1,2}:\\d{2}(am|pm|AM|PM){1}", "hh:mma");
            put("^\\d{1,2}:\\d{2}:\\{d2}(am|pm|AM|PM){1}", "hh:mm:ssa");
            // HH:MM:SS no AM/PM
            put("^\\d{1,2}:\\d{2}", "HH:mm");
            put("^\\d{1,2}:\\d{2}:\\{d2}", "HH:mm:ss");

            // HH.MM.SS AM/PM
            put("^\\d{1,2}\\.\\d{2}(am|pm|AM|PM){1}", "hh.mma");
            put("^\\d{1,2}\\.\\d{2}\\.\\{d2}(am|pm|AM|PM){1}", "hh.mm.ssa");
            // HH.MM.SS no AM/PM
            put("^\\d{1,2}\\.\\d{2}", "HH.mm");
            put("^\\d{1,2}\\.\\d{2}\\.\\{d2}", "HH.mm.ss");
        }
    };

    private static final LinkedHashMap<String, String> DATE_FORMAT_REGEX = new LinkedHashMap<String, String>() {
        private static final long serialVersionUID = 2L;
        {
            put("^\\d{8}$", "ddMMyyyy");
            put("^\\d{1,2}-\\d{1,2}-\\d{4}$", "dd-MM-yyyy");
            put("^\\d{4}-\\d{1,2}-\\d{1,2}$", "yyyy-MM-dd");
            put("^\\d{1,2}/\\d{1,2}/\\d{4}$", "dd/MM/yyyy");
            put("^\\d{4}/\\d{1,2}/\\d{1,2}$", "yyyy/MM/dd");

            put("^\\d{1,2}\\.\\d{1,2}\\.\\d{4}$", "dd.MM.yyyy");
            put("^\\d{4}\\.\\d{1,2}\\.\\d{1,2}$", "yyyy.MM.dd");

            put("^\\d{1,2}\\s[a-z]{3}\\s\\d{4}$", "dd MMM yyyy");
            put("^\\d{1,2}\\s[a-z]{4,}\\s\\d{4}$", "dd MMMM yyyy");

            // i.e 12th july 2014
            put("^\\d{1,2}th\\s[a-z]{3}\\s\\d{4}$", "dd MMM yyyy");
            put("^\\d{1,2}th\\s[a-z]{4,}\\s\\d{4}$", "dd MMMM yyyy");

        }
    };
    
    private static final HashMap<String, String> PARTIAL_DATE_FORMAT = new HashMap<String, String>() {
        private static final long serialVersionUID = 4L;
        {
            put("^\\d{1,2}-\\d{1,2}$", "-");
            put("^\\d{1,2}/\\d{1,2}$", "/");
        }
    };
    
	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\utils\DateUtil.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\utils\DateUtil.java
	 */

    public static boolean isTime(String token) {
        if (token == null) {
            return false;
        }
        return getTimeFormat(token) != null;
    }

    /**
     * Return the time format based on the token. If none is found, return a
     * null.
     * 
     * @param token
     * @return
     */
    public static String getTimeFormat(String token) {

        for (String regex : TIME_FORMAT_REGEX.keySet()) {
            LogHelper.log(CLASS_NAME, Level.INFO, "Matching " + token +
                    " with " +
                    regex);
            if (token.matches(regex)) {
                LogHelper.log(CLASS_NAME, Level.INFO, token + " matched with " +
                        regex);
                return TIME_FORMAT_REGEX.get(regex);
            }
        }
        return null;
    }

    /**
     * Convert to military time
     * 
     * @param token the time
     * @return the time converted to military format. If it's not parseable,
     * return null
     * @throws ParseException
     */
    public static String getMilitaryTime(String token) throws ParseException {
        if (!isTime(token)) {
            return null;
        }

        String timeFormat = getTimeFormat(token);
        String mockFormat = MILITARY_DATE_FORMAT + " " + timeFormat;
        String dateTimeStr = MOCK_DATE + " " + token;
        LogHelper.log(CLASS_NAME, Level.INFO, "Time format: " + timeFormat +
                "\n" +
                "Mock format: " +
                mockFormat +
                "\n" +
                "DateTime: " +
                dateTimeStr);

        SimpleDateFormat mockDateTimeFormat = new SimpleDateFormat(mockFormat);
        Date mockDate = mockDateTimeFormat.parse(dateTimeStr);

        SimpleDateFormat milTimeFormat = new SimpleDateFormat(
                MILITARY_TIME_FORMAT);
        return milTimeFormat.format(mockDate);
    }

    public static boolean isDate(String token) {
        if (token == null) {
            return false;
        }
        return getDateFormat(token) != null;
    }

    public static String getDateFormat(String token) {
        Pattern datePattern;
        Matcher dateMatcher;

        for (String regex : DATE_FORMAT_REGEX.keySet()) {
            datePattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
            dateMatcher = datePattern.matcher(token);
            if (dateMatcher.find()) {
                return DATE_FORMAT_REGEX.get(regex);
            }
        }
        return null;
    }

    public static String getMilitaryDate(String token) throws ParseException {

        if (!isDate(token)) {
            return null;
        }

        Date date = parse(token);
        SimpleDateFormat milDateFormat = new SimpleDateFormat(
                MILITARY_DATE_FORMAT);
        return milDateFormat.format(date);
    }

    public static boolean isPartialDate(String token) {
        return getPartialToken(token) != null;
    }

    public static String getPartialToken(String token) {
        Pattern partialDatePattern;
        Matcher partialDateMatcher;

        if (token == null) {
            return null;
        }
        for (String regex : PARTIAL_DATE_FORMAT.keySet()) {

            partialDatePattern = Pattern.compile(regex,
                    Pattern.CASE_INSENSITIVE);
            partialDateMatcher = partialDatePattern.matcher(token);

            if (partialDateMatcher.find()) {
                return PARTIAL_DATE_FORMAT.get(regex);
            }
        }

        return null;
    }

    public static String getDateFromPartial(String token) throws ParseException {

        if (token == null || !isPartialDate(token)) {
            return null;
        }
        String partialDate = token;
        String partialToken = getPartialToken(partialDate);
        int year = getToday().getYear();
        Date convertedDate = parse(partialDate + partialToken + year);
        SimpleDateFormat milDateFormat = new SimpleDateFormat(
                MILITARY_DATE_FORMAT);
        return milDateFormat.format(convertedDate);
    }

    public static DateTime getToday() {
        return DateTime.today(TimeZone.getDefault());
    }
    
	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\main\java\sg\edu\nus\cs2103t\mina\utils\DateUtil.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\controller\TaskFilterManagerFilterTest.java
	 */


public class TaskFilterManagerFilterTest {

    private static final int SEC = 2;
    private static final int MIN = 1;
    private static final int HOUR = 0;
    private static final int WEEK = 7;
    private static final int TODAY = 0;
    private static final boolean NO_TIME = false;
    private static final int END = 1;
    private static final int START = 0;
    private static final int DATE_RANGE_EVENT_EXPECTED_SIZE = 5;
    private static final int EVERYTHING = 0;
    private static final int COMPLETE = 1;
    private static final int UNCOMPLETE = 2;
    private static final boolean HAS_TIME = true;

    private TaskDataManagerStub tdmStub = new TaskDataManagerStub();
    private TaskFilterManager tfmTest = new TaskFilterManager(tdmStub);
    private static final String CLASS_NAME = TaskFilterManagerFilterTest.class
            .getName();

    /**
     * Test for passing an empty filter parameter Expected: Returned all
     * uncompleted tasks. In this case with the dummy data, everything should be
     * there.
     * 
     */
    @Test
    public void testNoFilter() {
        ArrayList<Task<?>> test = getResult(new FilterType[] {});
        assertTrue("Must have everything!", checkAllUncompletedTasks(test));

    }

    /**
     * Test for displaying deadlines only. Expected: Deadlines only. In this
     * case, all dummy data in deadlines.
     */
    @Test
    public void testDeadlinesOnly() {

        ArrayList<Task<?>> test = getResult(FilterType.DEADLINE);

        SortedSet<DeadlineTask> deadlines = tdmStub
                .getUncompletedDeadlineTasks();
        int numOfDeadlines = deadlines.size();

        assertTrue(
                "Must be all deadlines!",
                numOfDeadlines == test.size() && isTaskExist(test, deadlines,
                        TaskType.DEADLINE));

    }

    /**
     * Test for displaying Todos only. Expected: Todos only. In this case, all
     * dummy data in Todos.
     */
    @Test
    public void testTodosOnly() {

        ArrayList<Task<?>> test = getResult(FilterType.TODO);
        SortedSet<TodoTask> todos = tdmStub.getUncompletedTodoTasks();
        int numOfTodos = todos.size();

        assertTrue(
                "Must be all todos!",
                numOfTodos == test.size() && isTaskExist(test, todos,
                        TaskType.TODO));
    }

    /**
     * Test for displaying events only. Expected: Events only. In this case, all
     * dummy data in Events.
     */
    @Test
    public void testEventsOnly() {

        /* XXX EP: Either uncompleted event only or not at all */
        ArrayList<Task<?>> test = getResult(FilterType.EVENT);
        SortedSet<EventTask> events = tdmStub.getUncompletedEventTasks();
        int numOfEvents = events.size();

        assertTrue(
                "Must be all events!",
                numOfEvents == test.size() && isTaskExist(test, events,
                        TaskType.EVENT));
    }

    /**
     * Test for completed tasks only. Expected: Completed events only.
     */
    @Test
    public void testCompletedOnly() {

        ArrayList<Task<?>> test = getResult(FilterType.COMPLETE);
        ArrayList<Task<?>> allCompleted = getCompletedDummyTasks();

        assertTrue(
                "Tasks must be identical in both cases!",
                test.size() == allCompleted.size() && hasCompletedTasks(test,
                        allCompleted));

    }

    /**
     * Test for completed+ tasks Expected: Everything including completed tasks
     */
    @Test
    public void testCompletePlus() {
        ArrayList<Task<?>> test = getResult(FilterType.COMPLETE_PLUS);
        boolean hasEverything = checkEverything(test);
        assertTrue("Need everything!", hasEverything);
    }

    /**
     * Test for priority. Expected: Tasks are ranked from highest to lowest. In
     * the case of events, the closer the date, the more urgent it is.
     */
    @Test
    public void testPriority() {
        ArrayList<Task<?>> test = getResult(FilterType.PRIORITY);
        assertTrue("Priorities are not sorted!", checkPriority(test));
    }

    /**
     * Test for different combination of filter.
     */
    @Test
    public void testFilterCombination() {

        /* XXX Testing for EP: UNCOMPLETE DEADLINE UNCOMPLETE EVENT */
        /*
         * XXX Testing for EP: in fact, this test tries to cover all possible EP
         * P({UNCOMPLETE, COMPLETE} X {EVENT, DEADLINE, TODO})
         */

        // With deadlines and events
        FilterType[] filters = { FilterType.DEADLINE, FilterType.EVENT };

        ArrayList<Task<?>> test = getResult(filters);
        int actualSize = tdmStub.getUncompletedDeadlineTasks().size() + tdmStub
                .getUncompletedEventTasks().size();

        assertTrue(
                "Contains only uncompleted deadline and events!",
                actualSize == test.size() && checkTwoTaskTypes(test,
                        TaskType.DEADLINE, TaskType.EVENT, UNCOMPLETE));

        // With deadlines and todos
        filters = new FilterType[] { FilterType.DEADLINE, FilterType.TODO };
        test = getResult(filters);
        actualSize = tdmStub.getUncompletedDeadlineTasks().size() + tdmStub
                .getUncompletedTodoTasks().size();
        assertTrue(
                "Contains only uncompleted deadline and todos!",
                actualSize == test.size() && checkTwoTaskTypes(test,
                        TaskType.DEADLINE, TaskType.TODO, UNCOMPLETE));

        // With events and todos
        filters = new FilterType[] { FilterType.EVENT, FilterType.TODO };
        test = getResult(filters);
        actualSize = tdmStub.getUncompletedEventTasks().size() + tdmStub
                .getUncompletedTodoTasks().size();
        assertTrue(
                "Contains only uncompleted todos and events!",
                actualSize == test.size() && checkTwoTaskTypes(test,
                        TaskType.EVENT, TaskType.TODO, UNCOMPLETE));

        // With all events, todos and deadlines
        filters = new FilterType[] { FilterType.DEADLINE, FilterType.TODO,
                FilterType.EVENT };
        test = getResult(filters);
        actualSize = tdmStub.getUncompletedEventTasks().size() + tdmStub
                .getUncompletedTodoTasks().size() +
                tdmStub.getUncompletedDeadlineTasks().size();
        assertTrue("Contains all task!", checkAllUncompletedTasks(test));

        // Completed deadlines and events.
        filters = new FilterType[] { FilterType.COMPLETE, FilterType.EVENT,
                FilterType.DEADLINE };
        test = getResult(filters);
        actualSize = tdmStub.getCompletedEventTasks().size() + tdmStub
                .getCompletedDeadlineTasks().size();
        assertTrue(
                "Contains completed deadlines and events!",
                test.size() == actualSize && checkTwoTaskTypes(test,
                        TaskType.DEADLINE, TaskType.EVENT, COMPLETE));

        // Completed deadlines and todos.
        filters = new FilterType[] { FilterType.COMPLETE, FilterType.TODO,
                FilterType.DEADLINE };
        test = getResult(filters);
        actualSize = tdmStub.getCompletedTodoTasks().size() + tdmStub
                .getCompletedDeadlineTasks().size();
        assertTrue(
                "Contains completed deadlines and todos!",
                test.size() == actualSize && checkTwoTaskTypes(test,
                        TaskType.DEADLINE, TaskType.TODO, COMPLETE));

        // Completed event and todos.
        filters = new FilterType[] { FilterType.COMPLETE, FilterType.TODO,
                FilterType.EVENT };
        test = getResult(filters);
        actualSize = tdmStub.getCompletedTodoTasks().size() + tdmStub
                .getCompletedEventTasks().size();
        assertTrue(
                "Contains completed events and todos!",
                test.size() == actualSize && checkTwoTaskTypes(test,
                        TaskType.EVENT, TaskType.TODO, COMPLETE));

        // Get all completed
        filters = new FilterType[] { FilterType.COMPLETE };
        test = getResult(filters);
        actualSize = tdmStub.getCompletedTodoTasks().size() + tdmStub
                .getCompletedEventTasks().size() +
                tdmStub.getCompletedDeadlineTasks().size();
        assertTrue(
                "Contains all completed tasks",
                test.size() == actualSize && hasCompletedTasks(test,
                        getCompletedDummyTasks()));

        // Both completed and uncompleted event and todos.
        filters = new FilterType[] { FilterType.COMPLETE_PLUS, FilterType.TODO,
                FilterType.EVENT };
        test = getResult(filters);
        actualSize = tdmStub.getCompletedTodoTasks().size() + tdmStub
                .getCompletedEventTasks().size() +
                tdmStub.getUncompletedEventTasks().size() +
                tdmStub.getUncompletedTodoTasks().size();
        assertTrue(
                "Contains all event and todos!",
                test.size() == actualSize && checkTwoTaskTypes(test,
                        TaskType.EVENT, TaskType.TODO, EVERYTHING));

        // Both completed and uncompleted event and deadline.
        filters = new FilterType[] { FilterType.COMPLETE_PLUS,
                FilterType.DEADLINE, FilterType.EVENT };
        test = getResult(filters);
        actualSize = tdmStub.getCompletedDeadlineTasks().size() + tdmStub
                .getCompletedEventTasks().size() +
                tdmStub.getUncompletedEventTasks().size() +
                tdmStub.getUncompletedDeadlineTasks().size();
        assertTrue(
                "Contains all event and deadlines!",
                test.size() == actualSize && checkTwoTaskTypes(test,
                        TaskType.EVENT, TaskType.DEADLINE, EVERYTHING));

        // Both completed and uncompleted todo and deadline.
        filters = new FilterType[] { FilterType.COMPLETE_PLUS,
                FilterType.DEADLINE, FilterType.TODO };
        test = getResult(filters);
        actualSize = tdmStub.getCompletedDeadlineTasks().size() + tdmStub
                .getCompletedTodoTasks().size() +
                tdmStub.getUncompletedTodoTasks().size() +
                tdmStub.getUncompletedDeadlineTasks().size();
        assertTrue(
                "Contains all deadlines and todos!",
                test.size() == actualSize && checkTwoTaskTypes(test,
                        TaskType.TODO, TaskType.DEADLINE, EVERYTHING));

        // No task type filters, only +complete
        filters = new FilterType[] { FilterType.COMPLETE_PLUS };
        test = getResult(filters);
        actualSize = tdmStub.getCompletedDeadlineTasks().size() + tdmStub
                .getCompletedTodoTasks().size() +
                tdmStub.getUncompletedTodoTasks().size() +
                tdmStub.getUncompletedDeadlineTasks().size() +
                tdmStub.getCompletedEventTasks().size() +
                tdmStub.getUncompletedEventTasks().size();

        assertTrue("Contains everything!",
                test.size() == actualSize && checkEverything(test));

        // Testing with priority keyword for single, two and
        // all task type

        // Single task
        filters = new FilterType[] { FilterType.PRIORITY, FilterType.DEADLINE };
        test = getResult(filters);
        Iterator<DeadlineTask> deadlineSet = tdmStub
                .getUncompletedDeadlineTasks().iterator();
        ArrayList<DeadlineTask> deadlines = new ArrayList<DeadlineTask>();

        while (deadlineSet.hasNext()) {
            deadlines.add(deadlineSet.next());
        }

        assertEquals(test, deadlines);

        // Double task
        filters = new FilterType[] { FilterType.PRIORITY, FilterType.DEADLINE,
                FilterType.TODO };
        test = getResult(filters);
        actualSize = tdmStub.getUncompletedTodoTasks().size() + tdmStub
                .getUncompletedDeadlineTasks().size();
        assertTrue(
                "Contains deadlines and todos!",
                test.size() == actualSize && checkTwoTaskTypes(test,
                        TaskType.DEADLINE, TaskType.TODO, UNCOMPLETE));

        // All tasks
        filters = new FilterType[] { FilterType.PRIORITY };
        test = getResult(filters);
        actualSize = tdmStub.getUncompletedEventTasks().size() + tdmStub
                .getUncompletedTodoTasks().size() +
                tdmStub.getUncompletedDeadlineTasks().size();
        assertTrue("Contains all task!", checkAllUncompletedTasks(test));
    }

    /**
     * Test the date filter by range, start to end
     */
    @Test
    public void testDateFilterByRange() {

        tdmStub = new TaskDataManagerStub(TaskDataManagerStub.DATE_RANGE_SEARCH);
        tfmTest = new TaskFilterManager(tdmStub);

        FilterType[] dateFilters = new FilterType[] { FilterType.EVENT };
        Iterator<EventTask> eventsIter = tdmStub.getUncompletedEventTasks()
                .iterator();
        ArrayList<EventTask> events = new ArrayList<EventTask>();

        while (eventsIter.hasNext()) {
            events.add(eventsIter.next());
        }

        Iterator<DeadlineTask> deadlinesIter = tdmStub
                .getUncompletedDeadlineTasks().iterator();
        ArrayList<DeadlineTask> deadlines = new ArrayList<DeadlineTask>();

        while (deadlinesIter.hasNext()) {
            deadlines.add(deadlinesIter.next());
        }
        LogHelper.log(CLASS_NAME, Level.INFO, "Events: " + events +
                "Deadlines: " +
                deadlines);

        // Test dates only. No time (00:00)
        // A week from now.
        LogHelper.log(CLASS_NAME, Level.INFO, "Testing dates with only");
        Date[] dateRange = getRange(TODAY, new int[0], WEEK, new int[0],
                NO_TIME);
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Date Range: " + Arrays.toString(dateRange));
        ArrayList<Task<?>> test = getResult(dateFilters, dateRange[START],
                dateRange[END], NO_TIME);

        ArrayList<Task<?>> expected = new ArrayList<Task<?>>();

        for (int i = 0; i < DATE_RANGE_EVENT_EXPECTED_SIZE; i++) {
            expected.add(events.get(i));
        }
        assertEquals(expected, test);

        // Test date with time.
        // A week from now.
        LogHelper.log(CLASS_NAME, Level.INFO, "Testing date with time");
        dateRange = getRange(2, new int[] { 12, 0, 0 }, 5,
                new int[] { 9, 0, 0 }, HAS_TIME);
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Date Range: " + Arrays.toString(dateRange));
        test = getResult(dateFilters, dateRange[START], dateRange[END],
                HAS_TIME);

        expected = new ArrayList<Task<?>>();
        for (int i = 2; i < 5; i++) {
            expected.add(events.get(i));
        }
        assertEquals(expected, test);

        // Test date with start only
        LogHelper.log(CLASS_NAME, Level.INFO, "Testing date with start only");
        dateRange = getRange(TODAY, new int[0], 0, new int[0], NO_TIME);
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Date Range: " + Arrays.toString(dateRange));
        test = getResult(dateFilters, dateRange[START], null, HAS_TIME);
        assertEquals(events, test);

        // Test date with end only
        LogHelper.log(CLASS_NAME, Level.INFO, "Testing date with end only");
        dateRange = getRange(2, new int[] { 12, 00, 0 }, 5,
                new int[] { 9, 0, 0 }, HAS_TIME);
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Date Range: " + Arrays.toString(dateRange));
        test = getResult(dateFilters, null, dateRange[END], HAS_TIME);

        expected = new ArrayList<Task<?>>();
        for (int i = 0; i < 5; i++) {
            expected.add(events.get(i));
        }
        assertEquals(expected, test);

        LogHelper.log(CLASS_NAME, Level.INFO, "Testing for middle");
        LogHelper.log(CLASS_NAME, Level.INFO, "Getting Date range");
        dateRange = getRange(2, new int[] { 12, 00, 0 }, 5,
                new int[] { 9, 0, 0 }, HAS_TIME);
        test = getResult(dateFilters, null, dateRange[END], HAS_TIME);

        expected = new ArrayList<Task<?>>();
        for (int i = 0; i < 5; i++) {
            expected.add(events.get(i));
        }
        assertEquals(expected, test);

        // Checking for overlaps
        // Events only
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Testing overlaps: START < event.start but END > event.start ");
        LogHelper.log(CLASS_NAME, Level.INFO, "Getting date range");
        dateRange = getRange(TODAY, new int[] { 0, 0, 0 }, 1, new int[] { 12,
                0, 0 }, HAS_TIME);
        test = getResult(dateFilters, dateRange[START], dateRange[END],
                HAS_TIME);
        expected = new ArrayList<Task<?>>();
        expected.add(events.get(0));
        assertEquals(expected, test);

        LogHelper.log(CLASS_NAME, Level.INFO,
                "Testing overlaps: START < event.end but END > event.end ");
        LogHelper.log(CLASS_NAME, Level.INFO, "Getting date range");
        dateRange = getRange(1, new int[] { 4, 45, 0 }, 0,
                new int[] { 6, 0, 0 }, HAS_TIME);
        test = getResult(dateFilters, dateRange[START], dateRange[END],
                HAS_TIME);
        expected = new ArrayList<Task<?>>();
        expected.add(events.get(0));
        assertEquals(expected, test);

        LogHelper
                .log(CLASS_NAME, Level.INFO,
                        "Testing strict subset: START > event.start and END < event.end ");
        LogHelper.log(CLASS_NAME, Level.INFO, "Getting date range");
        dateRange = getRange(1, new int[] { 4, 45, 0 }, 0,
                new int[] { 5, 0, 0 }, HAS_TIME);
        test = getResult(dateFilters, dateRange[START], dateRange[END],
                HAS_TIME);
        expected = new ArrayList<Task<?>>();
        expected.add(events.get(0));
        assertEquals(expected, test);

        LogHelper.log(CLASS_NAME, Level.INFO,
                "Testing equality: START = event.start and END > event.end ");
        LogHelper.log(CLASS_NAME, Level.INFO, "Getting date range");
        dateRange = getRange(1, new int[] { 3, 45, 0 }, 0, new int[] { 20, 30,
                0 }, HAS_TIME);
        test = getResult(dateFilters, dateRange[START], dateRange[END],
                HAS_TIME);
        expected = new ArrayList<Task<?>>();
        expected.add(events.get(0));
        assertEquals(expected, test);

        LogHelper.log(CLASS_NAME, Level.INFO,
                "Testing equality: START < event.start and END = event.end ");
        LogHelper.log(CLASS_NAME, Level.INFO, "Getting date range");
        dateRange = getRange(1, new int[] { 2, 15, 0 }, 0,
                new int[] { 5, 45, 0 }, HAS_TIME);
        test = getResult(dateFilters, dateRange[START], dateRange[END],
                HAS_TIME);
        expected = new ArrayList<Task<?>>();
        expected.add(events.get(0));
        assertEquals(expected, test);

        resetTdmTfm();

    }

    @Test
    /**
     * The ArrayList has already been tested.
     * Now, it's just to test whether the keys only
     * cover what the users want.
     * Note we need not do this on Search 
     */
    public void testHashMap() {
        ArrayList<String> newKeywords = new ArrayList<String>();
        FilterParameter param;
        HashMap<TaskType, ArrayList<Task<?>>> result;

        // Test one type
        newKeywords.add("deadline");
        param = new FilterParameter(newKeywords);
        result = tfmTest.filterTask(param);
        assertTrue(
                "Must contain only DEADLINE",
                result.containsKey(TaskType.DEADLINE) && result.keySet().size() == 1);
        newKeywords.clear();

        // Test two type
        newKeywords.add("deadline");
        newKeywords.add("event");
        param = new FilterParameter(newKeywords);
        result = tfmTest.filterTask(param);
        assertTrue(
                "Must contain only DEADLINE and Event",
                result.containsKey(TaskType.DEADLINE) && result
                        .containsKey(TaskType.EVENT) &&
                        result.keySet().size() == 2);
        newKeywords.clear();

        // Test three types
        param = new FilterParameter(newKeywords);
        result = tfmTest.filterTask(param);
        assertTrue(
                "Must contain only DEADLINE and TODO",
                result.containsKey(TaskType.DEADLINE) && result
                        .containsKey(TaskType.EVENT) &&
                        result.containsKey(TaskType.TODO) &&
                        result.keySet().size() == 3);
        newKeywords.clear();
    }

    /*
     * Test the date range
     */
    /**
     * Get the range of date.
     * 
     * @param startNumDay How many days from 'today'
     * @param startMs Start time, an int array of size 3, hour/min/sec in that
     * order
     * @param range How many days from 'start' parameter
     * @param endMs End time, an int array of size 3, hour/min/sec in that order
     * @param hasTime Does it have time?
     * @return Date array of size 2. START and END in that order
     */
    private Date[] getRange(int startNumDay, int[] startMs, int range,
            int[] endMs, boolean hasTime) {

        Calendar startDate = Calendar.getInstance();
        startDate.setTime(new Date(TaskDataManagerStub.START_TIME));
        startDate.setTimeZone(TimeZone.getTimeZone("UTC"));

        int year = startDate.get(Calendar.YEAR);
        int month = startDate.get(Calendar.MONTH);
        int startDay = startDate.get(Calendar.DAY_OF_MONTH) + startNumDay;
        if (hasTime) {
            startDate.set(year, month, startDay, startMs[HOUR], startMs[MIN],
                    startMs[SEC]);
        } else {
            startDate.set(year, month, startDay, 0, 0, 0);
        }

        LogHelper.log(CLASS_NAME, Level.INFO, "START: " + startDate.getTime());

        Calendar endDate = Calendar.getInstance();
        endDate.setTimeZone(TimeZone.getTimeZone("UTC"));
        endDate.setTime(startDate.getTime());

        if (hasTime) {
            endDate.set(startDate.get(Calendar.YEAR),
                    startDate.get(Calendar.MONTH),
                    startDate.get(Calendar.DAY_OF_MONTH) + range, endMs[HOUR],
                    endMs[MIN], endMs[SEC]);
        } else {
            endDate.set(startDate.get(Calendar.YEAR),
                    startDate.get(Calendar.MONTH),
                    startDate.get(Calendar.DAY_OF_MONTH) + range, 0, 0, 0);
        }

        LogHelper.log(CLASS_NAME, Level.INFO, "END: " + endDate.getTime());
        return new Date[] { startDate.getTime(), endDate.getTime() };
    }

    private boolean checkTwoTaskTypes(ArrayList<Task<?>> test,
            TaskType firstType, TaskType secondType, int taskStatus) {

        if (test.isEmpty()) {
            return false;
        }

        for (Task<?> task : test) {
            if (!isValidInTaskCombi(task, firstType, secondType, taskStatus)) {
                return false;
            }
        }

        return true;
    }

    private boolean isValidInTaskCombi(Task<?> task, TaskType firstType,
            TaskType secondType, int taskStatus) {

        TaskType currType = task.getType();
        boolean isCorrectType = currType == firstType || currType == secondType;

        if (taskStatus == EVERYTHING) {
            return isCorrectType;
        } else {
            return isCorrectStatus(task.isCompleted(), taskStatus) && isCorrectType;
        }
    }

    private boolean isCorrectStatus(boolean isCompleted, int taskStatus) {
        return (isCompleted && taskStatus == COMPLETE) || (!isCompleted && taskStatus == UNCOMPLETE);
    }

    private boolean checkPriority(ArrayList<Task<?>> test) {

        int orderPriority = 0;
        Date prevCreatedEvent = new Date(0);
        Date prevCreatedDeadline = new Date(0);

        if (test.isEmpty()) {
            return false;
        }

        for (Task<?> task : test) {
            // todo task in the order of HHHHHH...MMMMMM...LLLL
            if (task instanceof TodoTask) {
                TodoTask todo = (TodoTask) task;
                orderPriority = checkTodoContiguity(todo, orderPriority);
                if (orderPriority != -1) {
                    continue;
                }
            } else if (task instanceof EventTask) {
                EventTask event = (EventTask) task;
                Date currDate = event.getStartTime();
                if (currDate.after(prevCreatedEvent)) {
                    prevCreatedEvent = currDate;
                    continue;
                }
            } else if (task instanceof DeadlineTask) {
                DeadlineTask deadline = (DeadlineTask) task;
                Date currDate = deadline.getEndTime();
                if (currDate.after(prevCreatedDeadline)) {
                    prevCreatedDeadline = currDate;
                    continue;
                }
            }
            return false;
        }

        return true;
    }

    /**
     * 
     * @param todo
     * @param orderPriority
     * @return
     */
    private int checkTodoContiguity(TodoTask todo, int orderPriority) {

        int currPriority;

        switch (todo.getPriority()) {
            case 'H' :
                currPriority = 0;
                break;
            case 'M' :
                currPriority = 1;
                break;
            case 'L' :
                currPriority = 2;
                break;
            default :
                return -1;
        }

        if (currPriority >= orderPriority) {
            return currPriority;
        } else {
            return -1;
        }

    }

    private boolean checkEverything(ArrayList<Task<?>> test) {

        SortedSet<TodoTask> todos = tdmStub.getUncompletedTodoTasks();
        SortedSet<TodoTask> todosComp = tdmStub.getCompletedTodoTasks();

        SortedSet<EventTask> events = tdmStub.getUncompletedEventTasks();
        SortedSet<EventTask> eventsComp = tdmStub.getCompletedEventTasks();

        SortedSet<DeadlineTask> deadlines = tdmStub
                .getUncompletedDeadlineTasks();
        SortedSet<DeadlineTask> deadlinesComp = tdmStub
                .getCompletedDeadlineTasks();

        int totalTaskSize = deadlinesComp.size() + eventsComp.size() +
                todosComp.size() +
                todos.size() +
                events.size() +
                deadlines.size();

        for (Task<?> task : test) {

            if (task instanceof DeadlineTask && !(deadlinesComp.contains(task) || deadlines
                    .contains(task))) {
                return false;
            }

            if (task instanceof TodoTask && !(todosComp.contains(task) || todos
                    .contains(task))) {
                return false;
            }

            if (task instanceof EventTask && !(eventsComp.contains(task) || events
                    .contains(task))) {
                return false;
            }

        }

        return totalTaskSize == test.size();
    }

    private boolean hasCompletedTasks(ArrayList<Task<?>> test,
            ArrayList<Task<?>> allCompleted) {

        if (test.isEmpty()) {
            return false;
        }

        for (Task<?> t : test) {
            if (!allCompleted.contains(t)) {
                return false;
            }
        }

        return true;
    }

    private ArrayList<Task<?>> getCompletedDummyTasks() {

        SortedSet<EventTask> events = tdmStub.getCompletedEventTasks();
        Iterator<EventTask> eventIter = events.iterator();

        SortedSet<DeadlineTask> deadlines = tdmStub.getCompletedDeadlineTasks();
        Iterator<DeadlineTask> deadlineIter = deadlines.iterator();

        SortedSet<TodoTask> todos = tdmStub.getCompletedTodoTasks();
        Iterator<TodoTask> todosIter = todos.iterator();

        ArrayList<Task<?>> tasks = new ArrayList<Task<?>>();

        while (todosIter.hasNext()) {
            tasks.add(todosIter.next());
        }

        while (eventIter.hasNext()) {
            tasks.add(eventIter.next());
        }

        while (deadlineIter.hasNext()) {
            tasks.add(deadlineIter.next());
        }

        return tasks;
    }

    /**
     * Get the result based on the keywords entered
     * 
     * @param cmd the string of keywords
     * @return An arrayList of tasks.
     */
    private ArrayList<Task<?>> getResult(FilterType[] filters) {
        return getResult(filters, null, null, false);
    }

    private ArrayList<Task<?>> getResult(FilterType cmd) {

        FilterType[] tokens = { cmd };
        return getResult(tokens);

    }

    private ArrayList<Task<?>> getResult(FilterType[] filters, Date start,
            Date end, boolean hasTime) {

        ArrayList<String> keywords = new ArrayList<String>();

        for (int i = 0; i < filters.length; i++) {
            keywords.add(filters[i].getType());
        }

        FilterParameter filter = new FilterParameter(keywords, start, end,
                hasTime);
        HashMap<TaskType, ArrayList<Task<?>>> resultMap = tfmTest
                .filterTask(filter);

        ArrayList<Task<?>> result = new ArrayList<Task<?>>();

        for (TaskType type : resultMap.keySet()) {
            result.addAll(resultMap.get(type));
        }

        return result;
    }

    /**
     * Compare the returned result to dummy data
     * 
     * @param test the arraylist of tasks
     * @param taskTree the dummy data for task
     * @param type the TaskType specified.
     * @return true if everything in the result is in specified tasks
     */
    private boolean isTaskExist(ArrayList<Task<?>> test,
            SortedSet<? extends Task<?>> taskTree, TaskType type) {

        for (Iterator<Task<?>> iterator = test.iterator(); iterator.hasNext();) {
            Task<?> task = iterator.next();
            if (!(isTask(task, type) && taskTree.contains(task))) {
                return false;
            }
        }

        return true;
    }

    @SuppressWarnings("rawtypes")
    private boolean isTask(Task task, TaskType type) {

        boolean isTask;

        switch (type) {
            case DEADLINE :
                isTask = task instanceof DeadlineTask;
                break;
            case TODO :
                isTask = task instanceof TodoTask;
                break;
            case EVENT :
                isTask = task instanceof EventTask;
                break;
            default :
                isTask = false;
        }

        return isTask;
    }

    /**
     * To compare with tasks for now. The current task compareTo has a bug.
     * 
     * @param task
     * @param todoTasks
     * @return true if they match. False, if they don't
     */
    @SuppressWarnings({ "rawtypes", "unused" })
    private boolean compareTodo(Task task, TreeSet<TodoTask> todoTasks) {

        Iterator<TodoTask> todoIter = todoTasks.iterator();

        while (todoIter.hasNext()) {
            TodoTask todo = todoIter.next();
            if (todo.getDescription().equals(task.getDescription())) {
                return true;
            }
        }

        return false;
    }

    private boolean checkAllUncompletedTasks(ArrayList<Task<?>> test) {

        boolean isExist = true;

        for (Iterator<Task<?>> iterator = test.iterator(); iterator.hasNext();) {
            Task<?> t = iterator.next();
            if (t instanceof TodoTask) {
                isExist = tdmStub.getUncompletedTodoTasks().contains(
                        (TodoTask) t);
            } else if (t instanceof EventTask) {
                isExist = tdmStub.getUncompletedEventTasks().contains(
                        (EventTask) t);
            } else if (t instanceof DeadlineTask) {
                isExist = tdmStub.getUncompletedDeadlineTasks().contains(
                        (DeadlineTask) t);
            }
            if (!isExist) {
                break;
            }
        }
        return isExist;
    }

    @SuppressWarnings("rawtypes")
    public String toStringForTask(Task task) {
        String format = "UUID: %1$s\n" + "Type: %2$s\n"
                + "Description: %3$s\n"
                + "Tags: %4$s\n"
                + "Priority: %5$s\n"
                + "Created: %6$s\n"
                + "Last modified: %7$s\n"
                + "Completed: %8$s\n\n";
        String output = String.format(format, task.getId(), task.getType()
                .getType(), task.getDescription(), task.getTag(), task
                .getPriority(), task.getCreatedTime(),
                task.getLastEditedTime(), task.isCompleted());
        return output;
    }

    public void printEvent(EventTask task) {
        String format = "Start: %1$s\n" + "End: %2$s\n";
        LogHelper.log(CLASS_NAME, Level.INFO, toStringForTask(task));
        LogHelper.log(CLASS_NAME, Level.INFO,
                String.format(format, task.getStartTime(), task.getEndTime()));
    }

    public void printDeadline(DeadlineTask task) {
        String format = "End: %1$s\n";
        LogHelper.log(CLASS_NAME, Level.INFO, toStringForTask(task));
        LogHelper.log(CLASS_NAME, Level.INFO,
                String.format(format, task.getEndTime()));
    }

    public void printTodo(TodoTask task) {
        LogHelper.log(CLASS_NAME, Level.INFO, toStringForTask(task));
    }

    public void resetTdmTfm() {
        tdmStub = new TaskDataManagerStub();
        tfmTest = new TaskFilterManager(tdmStub);
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\controller\TaskFilterManagerFilterTest.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\controller\TaskFilterManagerSearchTest.java
	 */


public class TaskFilterManagerSearchTest {

    private TaskDataManagerStub tdmStub = new TaskDataManagerStub();
    private TaskFilterManager tfmTest = new TaskFilterManager(tdmStub);
    private static final String CLASS_NAME = TaskFilterManagerSearchTest.class
            .getName();

    @Test
    public void testEmptySearch() {
        // TODO Splitting by " " may have unintended effects,
        // e.g "        s           " is going to give us alot of false positive
        ArrayList<Task<?>> test = getResult("");
        assertEquals(new ArrayList<Task<?>>(), test);
    }

    @Test
    public void testOneKeyword() {

        ArrayList<Task<?>> test = getResult("deadline");

        Iterator<DeadlineTask> expectedIter = tdmStub
                .getUncompletedDeadlineTasks().iterator();
        ArrayList<DeadlineTask> expected = new ArrayList<DeadlineTask>();

        while (expectedIter.hasNext()) {
            expected.add(expectedIter.next());
        }

        assertEquals(expected, test);

        // test = getResult("1");
        // assertTrue("Only three tasks",
        // test.size()==3 &&
        // compareToActualTasks(test));
    }

    @Test
    public void testTwoWordsAndMore() {

        ArrayList<Task<?>> test = getResult("deadline event");
        int expectedSize = tdmStub.getUncompletedDeadlineTasks().size() + tdmStub
                .getUncompletedEventTasks().size();
        assertTrue("Must contain deadline and event",
                test.size() == expectedSize && compareToActualTasks(test));

    }

    /**
     * Test to ensure punctuation are ignored.
     */
    @Test
    public void testPunctuations() {

        tdmStub = new TaskDataManagerStub(
                TaskDataManagerStub.PUNCTUATION_SEARCH);
        tfmTest = new TaskFilterManager(tdmStub);

        ArrayList<TodoTask> test = convertToTodos(getResult("walk the"));

        ArrayList<TodoTask> expected = new ArrayList<TodoTask>();
        expected.add(new TodoTask("1. Do laundry, grocery and walk the dog"));
        expected.add(new TodoTask("2. Buy the new Zack Hemsey's album"));
        assertEquals(expected, test);
        expected.clear();

        test = convertToTodos(getResult("laundry"));
        expected.add(new TodoTask("1. Do laundry, grocery and walk the dog"));
        assertEquals(expected, test);
        expected.clear();

        resetTdmTfm();
    }

    private ArrayList<TodoTask> convertToTodos(ArrayList<Task<?>> result) {
        ArrayList<TodoTask> todos = new ArrayList<TodoTask>();
        for (Task<?> task : result) {
            todos.add((TodoTask) task);
        }
        return todos;
    }

    private boolean compareToActualTasks(ArrayList<Task<?>> test) {

        // guard clause
        if (test.isEmpty()) {
            return false;
        }

        Iterator<DeadlineTask> deadlineIter = tdmStub
                .getUncompletedDeadlineTasks().iterator();
        ArrayList<DeadlineTask> deadlines = new ArrayList<DeadlineTask>();

        while (deadlineIter.hasNext()) {
            deadlines.add(deadlineIter.next());
        }

        Iterator<EventTask> eventIter = tdmStub.getUncompletedEventTasks()
                .iterator();
        ArrayList<EventTask> events = new ArrayList<EventTask>();

        while (eventIter.hasNext()) {
            events.add(eventIter.next());
        }

        Iterator<TodoTask> todoIter = tdmStub.getUncompletedTodoTasks()
                .iterator();
        ArrayList<TodoTask> todos = new ArrayList<TodoTask>();

        while (todoIter.hasNext()) {
            todos.add(todoIter.next());
        }

        for (Task<?> task : test) {
            if (task instanceof TodoTask && !todos.contains((TodoTask) task)) {
                LogHelper.log(CLASS_NAME, Level.INFO,
                        ((TodoTask) task).toString());
                return false;
            }
            if (task instanceof EventTask && !events.contains((EventTask) task)) {
                LogHelper.log(CLASS_NAME, Level.INFO,
                        ((EventTask) task).toString());
                return false;
            }
            if (task instanceof DeadlineTask && !deadlines
                    .contains((DeadlineTask) task)) {
                LogHelper.log(CLASS_NAME, Level.INFO,
                        ((DeadlineTask) task).toString());
                return false;
            }

        }

        return true;
    }

    public ArrayList<Task<?>> getResult(String rawKeywords) {

        String[] tokens = rawKeywords.split(" ");
        ArrayList<String> keywords = new ArrayList<String>();
        SearchParameter searchParam;

        for (int i = 0; i < tokens.length; i++) {
            if (!tokens[i].trim().equals("")) {
                keywords.add(tokens[i]);
            }
        }

        searchParam = new SearchParameter(keywords);
        HashMap<TaskType, ArrayList<Task<?>>> resultMap = tfmTest
                .searchTasks(searchParam);

        ArrayList<Task<?>> result = new ArrayList<Task<?>>();

        for (TaskType type : resultMap.keySet()) {
            result.addAll(resultMap.get(type));
        }

        return result;

    }

    public void resetTdmTfm() {
        tdmStub = new TaskDataManagerStub();
        tfmTest = new TaskFilterManager(tdmStub);
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\controller\TaskFilterManagerSearchTest.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\steps\MinaDeadlineTaskSteps.java
	 */


public class MinaDeadlineTaskSteps extends MinaStepSkeleton {

    @Override
    protected Shell createShell() {
        return driver.guiTestSetUp();
    }
   
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\steps\MinaDeadlineTaskSteps.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\steps\MinaEventTaskSteps.java
	 */


public class MinaEventTaskSteps extends MinaStepSkeleton {

    @Override
    protected Shell createShell() {
        return driver.guiTestSetUp();
    }
    
    @Then("the <type> list at line number <daterangeline> should be a time range of <daterange>")
    public void checkDateRange(@Named("type") String type, @Named("daterangeline") int dateRangeLine, @Named("daterange") String date) {
        date = date.replace(NEXT_LINE, System.getProperty(LINE_SEPARATOR));
        date = date.replace(TAB, TAB_SEPARATOR);
        SWTBotStyledText list = getList(type);
        dateRangeLine-=1;
        Assert.assertNotNull(list);
        Assert.assertEquals(list.getTextOnLine(dateRangeLine), date);
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\steps\MinaEventTaskSteps.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\steps\MinaRecurringTaskSteps.java
	 */


public class MinaRecurringTaskSteps extends MinaStepSkeleton {

    @Override
    protected Shell createShell() {
        return driver.guiTestSetUp();
    }
    @Then("the <type> list at line number <recurline> should be <recur>")
    public void checkRecur(@Named("type") String type, @Named("recurline") int recurLine, @Named("recur") String recur) {
        recur = recur.replace(NEXT_LINE, System.getProperty(LINE_SEPARATOR));
        recur = recur.replace(TAB, TAB_SEPARATOR);
        SWTBotStyledText list = getList(type);
        recurLine-=1;
        Assert.assertNotNull(list);
        System.out.println("We have " + list.getTextOnLine(recurLine));
        Assert.assertEquals(list.getTextOnLine(recurLine), recur);
    }
}   

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\steps\MinaRecurringTaskSteps.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\stories\MinaDeadlineTaskIT.java
	 */


public class MinaDeadlineTaskIT extends JUnitStory {

    public MinaDeadlineTaskIT() {
        configuredEmbedder().embedderControls()
                .doGenerateViewAfterStories(true)
                .doIgnoreFailureInStories(false).doIgnoreFailureInView(false)
                .useThreads(MinaITConstant.THREAD_NUM)
                .useStoryTimeoutInSecs(MinaITConstant.TIME_OUT_IN_SECONDS);
    }

    @Override
    public Configuration configuration() {
        return new MostUsefulConfiguration()
                .useStoryReporterBuilder(new StoryReporterBuilder()
                        .withDefaultFormats().withFormats(CONSOLE, TXT,
                                IDE_CONSOLE, HTML));
    }

    @Override
    public InjectableStepsFactory stepsFactory() {
        return new InstanceStepsFactory(configuration(), new MinaDeadlineTaskSteps());
    }
}
	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\stories\MinaDeadlineTaskIT.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\stories\MinaEventTaskIT.java
	 */


public class MinaEventTaskIT extends JUnitStory {

    public MinaEventTaskIT() {
        configuredEmbedder().embedderControls()
                .doGenerateViewAfterStories(true)
                .doIgnoreFailureInStories(false).doIgnoreFailureInView(false)
                .useThreads(MinaITConstant.THREAD_NUM)
                .useStoryTimeoutInSecs(MinaITConstant.TIME_OUT_IN_SECONDS);
    }

    @Override
    public Configuration configuration() {
        return new MostUsefulConfiguration()
                .useStoryReporterBuilder(new StoryReporterBuilder()
                        .withDefaultFormats().withFormats(CONSOLE, TXT,
                                IDE_CONSOLE, HTML));
    }

    @Override
    public InjectableStepsFactory stepsFactory() {
        return new InstanceStepsFactory(configuration(), new MinaEventTaskSteps());
    }
}
	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\stories\MinaEventTaskIT.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\stories\MinaRecurringTaskIT.java
	 */


public class MinaRecurringTaskIT extends JUnitStory {

    public MinaRecurringTaskIT() {
        configuredEmbedder().embedderControls()
                .doGenerateViewAfterStories(true)
                .doIgnoreFailureInStories(false).doIgnoreFailureInView(false)
                .useThreads(MinaITConstant.THREAD_NUM)
                .useStoryTimeoutInSecs(MinaITConstant.TIME_OUT_IN_SECONDS);
    }

    @Override
    public Configuration configuration() {
        return new MostUsefulConfiguration()
                .useStoryReporterBuilder(new StoryReporterBuilder()
                        .withDefaultFormats().withFormats(CONSOLE, TXT,
                                IDE_CONSOLE, HTML));
    }

    @Override
    public InjectableStepsFactory stepsFactory() {
        return new InstanceStepsFactory(configuration(), new MinaRecurringTaskSteps());
    }
}
	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\stories\MinaRecurringTaskIT.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\stub\CommandProcessorStub.java
	 */


public class CommandProcessorStub extends CommandProcessor{
    
    public CommandProcessorStub() {
        super();
    }
    
    public TaskView processUserInput(String input){
        return new TaskView(input);
    }
    
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\stub\CommandProcessorStub.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\stub\TaskDataManagerStub.java
	 */


public class TaskDataManagerStub extends TaskDataManager {

    //Thu Jan 08 11:43:28 SGT 1970
    public static final int START_TIME = 620008200; 

    public static final int ONE_HOUR = 1000 * 60 * 60;
    public static final int ONE_DAY = ONE_HOUR * 24;
    public static final int ONE_WEEK = ONE_DAY * 7;
    
    public static final int PUNCTUATION_SEARCH = 0;
    public static final int DATE_RANGE_SEARCH = 1;
    public static final int SANITISED_DATE_RANGE_SEARCH = 2;
    
		private static SortedSet<TodoTask> _todoTasks;
    private static SortedSet<EventTask> _eventTasks;
    private static SortedSet<DeadlineTask> _deadlineTasks;

    private static SortedSet<TodoTask> _compTodoTasks;
    private static SortedSet<EventTask> _compEventTasks;
    private static SortedSet<DeadlineTask> _compDeadlineTasks;

    public TaskDataManagerStub() {

        super();

        _todoTasks = getUncompletedTodoTasks();
        _eventTasks = getUncompletedEventTasks();
        _deadlineTasks = getUncompletedDeadlineTasks();

        _compTodoTasks = getCompletedTodoTasks();
        _compEventTasks = getCompletedEventTasks();
        _compDeadlineTasks = getCompletedDeadlineTasks();
        
        _todoTasks.clear();
        _eventTasks.clear();
        _deadlineTasks.clear();
        
        _compTodoTasks.clear();
        _compEventTasks.clear();
        _compDeadlineTasks.clear();
        
        char[] roulette = { 'L', 'M', 'H' };
        
        for (int i = 0; i < 20; i++) {

            TodoTask newTodoTask = new TodoTask(
                    "Do item " + i + " on the list", roulette[i % 3]);
            if (i % 5 == 0) {
                newTodoTask.setCompleted(true);
                _compTodoTasks.add(newTodoTask);
            } else {
                _todoTasks.add(newTodoTask);
            }

            int time = ONE_DAY * (i+1);
            Date startTime = new Date();
            startTime.setTime(startTime.getTime() + time);

            Date endDate = new Date(startTime.getTime());
            endDate.setTime(startTime.getTime() + ONE_HOUR * 2);

            EventTask newEventTask = new EventTask("Event " + i, startTime,
                    endDate);
            if (i % 10 == 0) {
                // Make it into the past
                Date pastStart = new Date((new Date()).getTime() - time);
                newEventTask.setStartTime(pastStart);

                Date pastEnd = new Date(pastStart.getTime() + ONE_HOUR * 2);
                newEventTask.setEndTime(pastEnd);

                newEventTask.setCompleted(true);
                _compEventTasks.add(newEventTask);

            } else {
                _eventTasks.add(newEventTask);
            }

            time = ONE_DAY * (i+1) ;
            startTime = new Date();
            startTime.setTime(startTime.getTime() + time);

            DeadlineTask newDeadline = new DeadlineTask("Deadline " + i,
                    startTime);
            if (i % 6 == 0) {
                // Make it into the past
                Date pastEnd = new Date((new Date()).getTime() - time);
                newDeadline.setEndTime(pastEnd);
                newDeadline.setCompleted(true);
                _compDeadlineTasks.add(newDeadline);
            } else {
                _deadlineTasks.add(newDeadline);
            }

        }

    }
    
    public TaskDataManagerStub(int cases) {
    	
    	super();
    	
      _todoTasks = getUncompletedTodoTasks();
      _eventTasks = getUncompletedEventTasks();
      _deadlineTasks = getUncompletedDeadlineTasks();

      _compTodoTasks = getCompletedTodoTasks();
      _compEventTasks = getCompletedEventTasks();
      _compDeadlineTasks = getCompletedDeadlineTasks();
    	
    	switch(cases) {
    		case PUNCTUATION_SEARCH :
    			_todoTasks.clear();
    			_todoTasks.add(new TodoTask("1. Do laundry, grocery and walk the dog"));
    			_todoTasks.add(new TodoTask("2. Buy the new Zack Hemsey's album"));
    			_todoTasks.add(new TodoTask("3. Watch GITS 2nd gIg. Watch SAC as well."));
    			_todoTasks.add(new TodoTask("4. we , might . have ! a ; puntuation o problem } I {} think. "));
    			break;
    		case DATE_RANGE_SEARCH :
    		    
    		    _eventTasks.clear();
    		    _deadlineTasks.clear();
    		    
    		    Calendar baseDate = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
    		    baseDate.setTime(new Date(START_TIME));
    		   
    		    baseDate.set(baseDate.get(Calendar.YEAR), 
    		            baseDate.get(Calendar.MONTH), 
    		            baseDate.get(Calendar.DATE), 
    		            3, 45, 00);
    		    baseDate.setTimeZone(TimeZone.getTimeZone("UTC"));
    		    EventTask newEvent;
    		    DeadlineTask newDeadline;
    		    Date startDate;
    		    Date endDate;
    		    
    		    for(int i=0; i<5; i++) {
    		        
                    baseDate.set(baseDate.get(Calendar.YEAR), 
                            baseDate.get(Calendar.MONTH), 
                            baseDate.get(Calendar.DATE) + 1, 
                            3, 45, 00);
    		        
        		    startDate = baseDate.getTime();
        		    startDate.setTime(startDate.getTime());
        		    endDate = new Date(startDate.getTime() + 2 * ONE_HOUR);
        		    
        		    newDeadline = new DeadlineTask("Daily Deadline " + (i+1), startDate);
        		    newEvent = new EventTask("Dailies " + (i+1), startDate, endDate);
        		    _eventTasks.add(newEvent);
        		    _deadlineTasks.add(newDeadline);
    		    }
    		    
    		    baseDate.setTime(new Date(START_TIME));
    		    
    		    for (int i=0; i<3; i++) {
    		        
                    baseDate.set(baseDate.get(Calendar.YEAR), 
                            baseDate.get(Calendar.MONTH), 
                            baseDate.get(Calendar.DATE) + 7, 
                            3, 45, 00);
    		        
                    startDate = baseDate.getTime();
                    startDate.setTime(startDate.getTime() + (i+1)*ONE_WEEK);
                    endDate = new Date(startDate.getTime() + 2 * ONE_HOUR);
                    
                    newDeadline = new DeadlineTask("Weekly Deadline " + (i+1), startDate);
                    newEvent = new EventTask("Weekly " + (i+1), startDate, endDate);
                    _eventTasks.add(newEvent);
                    _deadlineTasks.add(newDeadline);
    		    }
    		    
    		    break;
    		    
          case SANITISED_DATE_RANGE_SEARCH :
                _deadlineTasks.clear();
                baseDate = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
                baseDate.setTime(new Date(START_TIME));            
                
                baseDate.set(baseDate.get(Calendar.YEAR), 
                        baseDate.get(Calendar.MONTH), 
                        baseDate.get(Calendar.DATE), 
                        23, 59, 59);
                
                Date end = baseDate.getTime();
                newDeadline = new DeadlineTask("Deadline 1",end);
                _deadlineTasks.add(newDeadline);
                break;
                
    		default:
    			throw new Error("Woah, no such test case yet!");
    	}
    	
    }
    
    public SortedSet<TodoTask> getCompTodoTasks() {
        return _compTodoTasks;
    }

    public SortedSet<EventTask> getCompEventTasks() {
        return _compEventTasks;
    }

    public SortedSet<DeadlineTask> getCompDeadlineTasks() {
        return _compDeadlineTasks;
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\stub\TaskDataManagerStub.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\CommandParserTest.java
	 */


public class CommandParserTest {

    private static final int ORDER_EVENT_EDS = 4;
    private static final int ORDER_EVENT_ESD = 3;
    private static final int ORDER_EVENT_SED = 2;
    private static final int ORDER_EVENT_SDE = 1;
    private static final int ORDER_EVENT_DES = 0;
    private static final boolean HAS_DASH = true;
    private static final boolean IS_REORDER = true;
    private static final boolean IS_WRAPPED = true;

    private CommandParser parser = new CommandParser();

    private StringBuilder variationBuild;
    private String variation;
    private String result;
    private String testTime;
    private String start;
    private String end;

    public static final String TODO_ONE = "CPT_todo1";
    public static final String TODO_TWO = "CPT_todo2";
    public static final String TODO_THREE = "CPT_todo3";
    public static final String TODO_FOUR = "CPT_todo4";

    public static final String DEADLINE_DESCRIPTION = "Submit assignment ";
    public static final String EVENT_DESCRIPTION = "meet friends";
    public static final String RECUR_DESCRIPTION = "CS2103 tutorial";
    private static final int HAS_SECS = 0;
    private static final int HAS_NO_SECS = 1;
    private static final int HAS_TODAY_NO_TIME_SLASH = 2;
    private static final int HAS_TODAY_NO_TIME_DOT = 3;
    private static final int HAS_TODAY_NO_TIME_DASH = 4;
    private static final int HAS_TODAY_NO_TIME_KEYWORD = 5;
    private static final int HAS_TODAY_TIME = 6;
    private static final int HAS_TODAY_TIME_AM = 7;
    private static final int HAS_NO_DATE_BUT_TIME_PM = 8;
    private static final int HAS_NO_DATE_BUT_MILITARY_TIME = 9;
    private static final int HAS_DATE_24_AUG_2014_0900 = 10;
    private static final int HAS_DATE_25_AUG_2014_1200 = 11;
    private static final int HAS_DATE_24_AUG_2014_2133 = 12;

    private static final int DEAFULT_END = 0;
    private static final int DUE_END = 1;
    private static final int BY_END = 2;
    private static final int BEFORE_END = 3;
    private static final int DEFAULT_START = 4;
    private static final int FROM_START = 5;
    private static final int STARTING_START = 6;

    private static String addTodoControlLow, addTodoControlMed,
            addTodoControlHigh, addTodoControlNone,
            addDeadlineControlMonthDaySecs, addDeadlineControlMonthDaySame,
            addDeadlineControlNoDate, addDeadlineControlNoDateMorning,
            addDeadlineControlTodayNoTime, addDeadlineControlMonthTimeNoSecs,
            addEventControlADay, addEventControlDays, addEventControlMonths,
            addEventControlYears, addEventControlToday, addRecurDayControl,
            addRecurWeekControl, addRecurMonthControl, addRecurYearControl;

    private static String displayControlType;

    private static DateTime thisFri, thisWed, thisSunday, nextFri, nextWed,
            nextSunday, threeDays, fourWeeks, fiveMonths, sixYears;

    private static DateTime today;
    private static final String CLASS_NAME = CommandParserTest.class.getName();

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {

        today = DateTime.today(TimeZone.getDefault());
        // Controls for adding todos
        addTodoControlLow = "add CPT_todo1 -priority L";
        addTodoControlMed = "add CPT_todo2 -priority M";
        addTodoControlHigh = "add CPT_todo3 -priority H";
        addTodoControlNone = "add CPT_todo4";

        String todayDateString = today.format("DDMMYYYY");

        // Today, time specified.
        addDeadlineControlNoDate = "add Submit assignment -end " + todayDateString +
                "200000";
        // Today, morning
        addDeadlineControlNoDateMorning = "add Submit assignment -end " + todayDateString +
                "090000";
        // Today no time specified
        addDeadlineControlTodayNoTime = "add Submit assignment -end " + todayDateString +
                "235959";
        // 26th of April 2013, time, no seconds.
        addDeadlineControlMonthTimeNoSecs = "add Submit assignment -end 26042013235900";
        // 26th of April 2013, 11:59:23pm
        addDeadlineControlMonthDaySecs = "add Submit assignment -end 26042013235923";
        // 4th of July 2013, 2359
        addDeadlineControlMonthDaySame = "add Submit assignment -end 04072013235900";

        // start: 24th of August 2014 0900 - 25th of August 2014 1200
        addEventControlADay = "add meet friends -start 24082014090000 -end 25082014120000";
        // start: 24th of August 2014 0900 - 31th of August 2014 1200
        addEventControlDays = "add meet friends -start 24082014090000 -end 31082014120000";
        // start: 24th of August 2014 0900 - 24th of September 2014 1200
        addEventControlMonths = "add meet friends -start 24082014090000 -end 24092014120000";
        // start: 24th of August 2014 0900 - 24th of September 2017 1200
        addEventControlYears = "add meet friends -start 24082014090000 -end 24092017120000";

        // start: today 9am - today 9.33pm
        addEventControlToday = "add meet friends -start " + todayDateString +
                "090000 -end " +
                todayDateString +
                "213300";

        // recurring task 24th August 2014 0900 - 24th August 2014 1100. Recur
        // until 23th November 2014
        addRecurDayControl = "add CS2103 tutorial -start 24082014090000 -end 24082014110000 -every day -until 23112014235959";
        addRecurWeekControl = "add CS2103 tutorial -start 24082014090000 -end 24082014110000 -every week -until 23112014235959";
        addRecurMonthControl = "add CS2103 tutorial -start 24082014090000 -end 24082014110000 -every month -until 23112014235959";
        // recurring task 24th August 2014 0900 - 24th August 2014 1100. Recur
        // until 23th November 2016
        addRecurYearControl = "add CS2103 tutorial -start 24082014090000 -end 24082014110000 -every year -until 23112016235959";

        // Basic type
        displayControlType = "display";

        for (FilterType filter : FilterType.values()) {
            if (!(filter.equals(FilterType.START) || filter
                    .equals(FilterType.END) || filter
                        .equals(FilterType.PRIORITY))) {
                displayControlType += " " + filter.getType();
            }
        }

        // Date phrases
        // wed //sun //fri
        int sun = 6;
        int wed = 2;
        int fri = 4;
        int weekday = (today.getWeekDay() - 1 + 6) % 7;
        thisSunday = today.plusDays(sun - weekday);
        thisWed = today.plusDays(wed - weekday);
        thisFri = today.plusDays(fri - weekday);

        nextSunday = thisSunday.plusDays(7);
        nextWed = thisWed.plusDays(7);
        nextFri = thisFri.plusDays(7);

        // Dynamic Date phrases
        // 3 days
        threeDays = today.plus(0, 0, 3, 0, 0, 0, 0,
                DateTime.DayOverflow.Spillover);
        // 4 weeks
        fourWeeks = today.plus(0, 0, 4 * 7, 0, 0, 0, 0,
                DateTime.DayOverflow.Spillover);
        // 5 months
        fiveMonths = today.plus(0, 5, 0, 0, 0, 0, 0,
                DateTime.DayOverflow.Spillover);
        // 6 years
        sixYears = today.plus(6, 0, 0, 0, 0, 0, 0,
                DateTime.DayOverflow.Spillover);
    }

    @Before
    public void setUp() {
        variationBuild = new StringBuilder();
        variation = result = testTime = start = end = "";

    }

    @Test(expected = NullPointerException.class)
    public void testNull() throws Exception {
        parser.convertCommand(null);
    }

    @Test(expected = ParseException.class)
    public void testEmptyString() throws Exception {
        parser.convertCommand("");
    }

    /**
     * Test to ensure that the control statements returned as it is.
     * 
     * @throws Exception
     */
    @Test
    public void testAddTodoControl() throws Exception {
        assertEquals(addTodoControlLow,
                parser.convertCommand(addTodoControlLow));
        assertEquals(addTodoControlMed,
                parser.convertCommand(addTodoControlMed));
        assertEquals(addTodoControlHigh,
                parser.convertCommand(addTodoControlHigh));
        assertEquals(addTodoControlNone,
                parser.convertCommand(addTodoControlNone));
    }

    /**
     * Testing for the different add command for todos.
     */
    @Test
    public void testReorderTodo() throws Exception {

        // Reordering of flags
        variationBuild.append("add ");
        variationBuild.append("-priority L ");
        variationBuild.append(TODO_ONE);
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlLow, result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append("-priority M ");
        variationBuild.append(TODO_TWO);
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlMed, result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append("-priority H ");
        variationBuild.append(TODO_THREE);
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlHigh, result);
    }

    @Test
    public void testDelimitTodo() throws Exception {
        // With delimiter of adding todos with low priority:
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(TODO_ONE));
        variationBuild.append(" priority l");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlLow, result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(TODO_TWO));
        variationBuild.append(" priority m");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlMed, result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(TODO_THREE));
        variationBuild.append(" priority h");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlHigh, result);

    }

    @Test
    public void testAddKeywords() throws Exception {

        variationBuild.append("make ");
        variationBuild.append(TODO_FOUR);
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlNone, result);

        setUp();
        variationBuild.append("create ");
        variationBuild.append(TODO_FOUR);
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlNone, result);

        setUp();
        variationBuild.append("new ");
        variationBuild.append(TODO_FOUR);
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlNone, result);

        setUp();
        variationBuild.append("+ ");
        variationBuild.append(TODO_FOUR);
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlNone, result);
    }

    @Test
    public void testPriorityKeywords() throws Exception {

        variationBuild.append("add ");
        variationBuild.append(wrapDescription(TODO_ONE));
        variationBuild.append(" low priority");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlLow, result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(TODO_ONE));
        variationBuild.append(" priority low");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlLow, result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(TODO_TWO));
        variationBuild.append(" med priority");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlMed, result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(TODO_TWO));
        variationBuild.append(" medium priority");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlMed, result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(TODO_THREE));
        variationBuild.append(" high priority");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlHigh, result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(TODO_THREE));
        variationBuild.append(" urgent");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(addTodoControlHigh, result);
    }

    // XXX Exploratory testing
    @Test
    public void exploratoryTest() throws Exception {

        variationBuild.append("add ");
        variationBuild.append(" urgent request from D");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals("add urgent request from D", result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription("urgent request from D"));
        variationBuild.append(" URGENT");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals("add urgent request from D -priority H", result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append("urgent request from D ");
        variationBuild.append(" -URGENT");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals("add urgent request from D -priority H", result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append("do priority low queue assignment ");
        variationBuild.append(" -priority high");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals("add do priority low queue assignment -priority H", result);

        setUp();
        variationBuild.append("add ");
        variationBuild
                .append("submit homework -due 12/3/2013 so that I could do something ");
        variation = variationBuild.toString();
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        result = parser.convertCommand(variation);
        assertEquals(
                "add submit homework so that I could do something -end 12032013235959",
                result);

        variation = "add today -end 0800 today tomorrow yesterday";
        result = parser.convertCommand(variation);
        String resultDate = today.format("DDMMYYYY");
        assertEquals("add today tomorrow yesterday -end " + resultDate +
                "080000", result);

        variation = "add before tomorrow 9.30am 'push harder'";
        result = parser.convertCommand(variation);
        DateTime tmr = today.plusDays(1);
        resultDate = tmr.format("DDMMYYYY");
        assertEquals("add push harder -end " + resultDate + "093000", result);

        variation = "add -description what";
        result = parser.convertCommand(variation);
        assertEquals("add \u2010description what", result);

        // filter no special
        variation = "filter deadline complete";
        result = parser.convertCommand(variation);
        assertEquals("display deadline complete", result);

        // filter start date
        variation = "filter -start 12/3/2007 deadline complete";
        result = parser.convertCommand(variation);
        assertEquals("display deadline complete -start 12032007000000", result);

        /*
         * XXX Boundary Value analysis, intersecting date format, dd/MM/yyyy
         * (another EP) with informal time (one EP)
         */
        // filter start date with time
        variation = "filter -start 12/3/2007 9am deadline complete";
        result = parser.convertCommand(variation);
        assertEquals("display deadline complete -start 12032007090000", result);

        // filter end date with time
        variation = "filter deadline -by today 2000 complete";
        result = parser.convertCommand(variation);
        resultDate = today.format("DDMMYYYY");
        end = resultDate + "200000";
        assertEquals("display deadline complete -end " + end, result);

        // filter start date and end date with time
        variation = "filter -from 12/5/2007 deadline -by today 2000 complete";
        result = parser.convertCommand(variation);
        resultDate = today.format("DDMMYYYY");
        end = resultDate + "200000";
        assertEquals(
                "display deadline complete -start 12052007000000 -end " + end,
                result);

    }

    @Test
    public void testDuplicatedFlag() {
        ArrayList<String> duplicates = new ArrayList<String>() {
            private static final long serialVersionUID = 9L;
            {
                add("add what -start today -end tmr -start tmr");
                add("add 'what -start' start today end tmr start tmr");
                add("add -every day recurring task -every hour until tmr");
                add("add every day 'recurring task' every hour until tmr");
                add("add every day 'recurring task' every hour until tmr");
                add("modify td 23 haha -taskid td34");
                add("modify td 23 haha -totype deadline -end tmr -totype event");
                add("modify td 23 haha -totype deadline -end tmr -totype event");
                add("add what -priority H -priority L");
                add("add 'what' -urgent -priority L");
                add("display -agendaof tmr deadline -start today");
            }
        };
        int expected = duplicates.size();
        boolean[] correctResult = new boolean[expected];
        int correctCount = 0;
        
        for(int i=0; i< expected; i++) {
            String err = duplicates.get(i);
            try{
                result = parser.convertCommand(err);
            } catch(ParseException e) {
                if(e.getMessage().startsWith("Duplicated")){
                    correctResult[i] = true;
                    correctCount++;
                }
            }
        }
        
        if(correctCount!=expected) {
            StringBuilder incorrectResult = new StringBuilder();
            for(int i=0; i<correctResult.length; i++) {
                if(!correctResult[i]) {
                    incorrectResult.append(duplicates.get(i));
                    incorrectResult.append("\n");
                }
            }
            fail("Incorrect results: \n" + 
                    incorrectResult.toString());
        }

    }

    @Test
    public void testAddDeadlinesControl() throws Exception {
        assertEquals(addDeadlineControlNoDate,
                parser.convertCommand(addDeadlineControlNoDate));
        assertEquals(addDeadlineControlNoDateMorning,
                parser.convertCommand(addDeadlineControlNoDateMorning));
        assertEquals(addDeadlineControlTodayNoTime,
                parser.convertCommand(addDeadlineControlTodayNoTime));
        assertEquals(addDeadlineControlMonthDaySecs,
                parser.convertCommand(addDeadlineControlMonthDaySecs));
        assertEquals(addDeadlineControlMonthTimeNoSecs,
                parser.convertCommand(addDeadlineControlMonthTimeNoSecs));
        assertEquals(addDeadlineControlMonthDaySame,
                parser.convertCommand(addDeadlineControlMonthDaySame));

    }

    /**
     * Test reorder of keywords
     * 
     * @throws Exception
     */
    @Test
    public void testAddDeadlineReorder() throws Exception {

        variationBuild.append("add ");
        variationBuild.append(getTestTime(HAS_SECS));
        variationBuild.append(DEADLINE_DESCRIPTION);
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlMonthDaySecs, result);

        setUp();
        variationBuild.append("add ");
        variationBuild.append(getTestTime(HAS_NO_SECS));
        variationBuild.append(DEADLINE_DESCRIPTION);
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlMonthTimeNoSecs, result);

    }

    /**
     * Testing for different -end words. Check for reorder, quotes and no quotes
     * 
     * @throws Exception
     */
    @Test
    public void testAddDeadlinesEndWords() throws Exception {

        // -end as control
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(DEADLINE_DESCRIPTION));
        variationBuild.append(getTestTime(HAS_NO_SECS, DEAFULT_END, false));
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        assertEquals(addDeadlineControlMonthTimeNoSecs, result);

        // due no dash
        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(DEADLINE_DESCRIPTION));
        variationBuild.append(getTestTime(HAS_NO_SECS, DUE_END, false));
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        assertEquals(addDeadlineControlMonthTimeNoSecs, result);

        // -due
        setUp();
        variationBuild.append("add ");
        variationBuild.append(DEADLINE_DESCRIPTION);
        variationBuild.append(getTestTime(HAS_NO_SECS, DUE_END, true));
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        assertEquals(addDeadlineControlMonthTimeNoSecs, result);

        // by no dash
        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(DEADLINE_DESCRIPTION));
        variationBuild.append(getTestTime(HAS_NO_SECS, BY_END, false));
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        assertEquals(addDeadlineControlMonthTimeNoSecs, result);

        // -by
        setUp();
        variationBuild.append("add ");
        variationBuild.append(DEADLINE_DESCRIPTION);
        variationBuild.append(getTestTime(HAS_NO_SECS, BY_END, true));
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlMonthTimeNoSecs, result);

        // before no dash
        setUp();
        variationBuild.append("add ");
        variationBuild.append(wrapDescription(DEADLINE_DESCRIPTION));
        variationBuild.append(getTestTime(HAS_NO_SECS, BEFORE_END, !HAS_DASH));
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlMonthTimeNoSecs, result);

        // -before
        setUp();
        variationBuild.append("add ");
        variationBuild.append(DEADLINE_DESCRIPTION);
        variationBuild.append(getTestTime(HAS_NO_SECS, BEFORE_END, true));
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlMonthTimeNoSecs, result);

    }

    /**
     * Test wrap and no wrap
     * 
     * @throws Exception
     */
    @Test
    public void testDateFormat() throws Exception {

        LogHelper.log(CLASS_NAME, Level.INFO,
                "Today's date is: " + today.toString());

        // testing today no time
        // no wrap with DD/MM/YYYY format
        variationBuild.append("add ");
        variationBuild.append(DEADLINE_DESCRIPTION);
        variationBuild.append(getTestTime(HAS_TODAY_NO_TIME_SLASH, BEFORE_END,
                HAS_DASH));
        variation = variationBuild.toString();
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlTodayNoTime, result);

        // With wrap
        variation = getDeadlineAddCmd(DEADLINE_DESCRIPTION,
                getTestTime(HAS_TODAY_NO_TIME_SLASH, BEFORE_END, HAS_DASH),
                !IS_REORDER, IS_WRAPPED);
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlTodayNoTime, result);

        // DD.MM.YYYY
        variation = getDeadlineAddCmd(DEADLINE_DESCRIPTION,
                getTestTime(HAS_TODAY_NO_TIME_DOT, BEFORE_END, HAS_DASH),
                !IS_REORDER, IS_WRAPPED);
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlTodayNoTime, result);

        // 'Today' keyword
        variation = getDeadlineAddCmd(DEADLINE_DESCRIPTION,
                getTestTime(HAS_TODAY_NO_TIME_KEYWORD, BEFORE_END, HAS_DASH),
                !IS_REORDER, IS_WRAPPED);
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlTodayNoTime, result);

        // 'Today' with time, 2000
        variation = getDeadlineAddCmd(DEADLINE_DESCRIPTION,
                getTestTime(HAS_TODAY_TIME, BEFORE_END, HAS_DASH), !IS_REORDER,
                IS_WRAPPED);
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlNoDate, result);

        // Today with time, 9am
        testTime = getTestTime(HAS_TODAY_TIME_AM, BEFORE_END, HAS_DASH);
        variation = getDeadlineAddCmd(DEADLINE_DESCRIPTION, testTime,
                !IS_REORDER, IS_WRAPPED);
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlNoDateMorning, result);

        // Today with no 'today' stated. Military
        testTime = getTestTime(HAS_NO_DATE_BUT_MILITARY_TIME, BEFORE_END,
                HAS_DASH);
        variation = getDeadlineAddCmd(DEADLINE_DESCRIPTION, testTime,
                !IS_REORDER, IS_WRAPPED);
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlNoDate, result);

        // Today with no 'today' stated. am
        // Today with no 'today' stated. Military
        testTime = getTestTime(HAS_NO_DATE_BUT_TIME_PM, BEFORE_END, HAS_DASH);
        variation = getDeadlineAddCmd(DEADLINE_DESCRIPTION, testTime,
                !IS_REORDER, IS_WRAPPED);
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addDeadlineControlNoDate, result);

        // Testing implicit today
        start = "-start today 9am";
        end = "-end 9.33pm";
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_DES, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addEventControlToday, result);

        // Testing for partial format
        String partialFormat = today.format("DD/MM");
        // String fullFormat = today.format("DDMMYYYY");
        start = "-start " + partialFormat + " 9:00";
        end = "-end " + partialFormat + " 21.33";
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_DES, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(addEventControlToday, result);

        // date phrase this wednesday ORDER_EVENT_SDE
        String thisWedStr = thisWed.format("DDMMYYYY");
        String thisFriStr = thisFri.format("DDMMYYYY");
        start = "-from this wednesday 3am";
        end = "-end friday 4am";
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_SDE, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        String expected = "add " + EVENT_DESCRIPTION +
                " -start " +
                thisWedStr +
                "030000 " +
                "-end " +
                thisFriStr +
                "040000";
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(expected, result);

        // date phrase next wednesday
        String nextWedStr = nextWed.format("DDMMYYYY");
        String nextSunStr = nextSunday.format("DDMMYYYY");
        start = "-from next wednesday 11:00am";
        end = "-end next sunday";
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_SDE, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        expected = "add " + EVENT_DESCRIPTION +
                " -start " +
                nextWedStr +
                "110000 " +
                "-end " +
                nextSunStr +
                "235959";
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(expected, result);

        // date phrase 3 days
        String threeDaysStr = threeDays.format("DDMMYYYY");
        start = "-from next 3 days 11:00pm";
        end = "-end next sunday";
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_SDE, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        expected = "add " + EVENT_DESCRIPTION +
                " -start " +
                threeDaysStr +
                "230000 " +
                "-end " +
                nextSunStr +
                "235959";
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(expected, result);

        // date phrase 4 weeks
        String fourWeeksStr = fourWeeks.format("DDMMYYYY");
        String nextFriStr = nextFri.format("DDMMYYYY");
        start = "-from next fri 22:39";
        end = "-end next 4 week 0900";
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_SED, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        expected = "add " + EVENT_DESCRIPTION +
                " -start " +
                nextFriStr +
                "223900 " +
                "-end " +
                fourWeeksStr +
                "090000";
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(expected, result);

        // date phrase 5 months
        // date phrase 6 years
        String fiveMonthsStr = fiveMonths.format("DDMMYYYY");
        String sixYearsStr = sixYears.format("DDMMYYYY");
        start = "-from next 5 months 10.46am";
        end = "-end next 6 years 9am";
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_EDS, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        expected = "add " + EVENT_DESCRIPTION +
                " -start " +
                fiveMonthsStr +
                "104600 " +
                "-end " +
                sixYearsStr +
                "090000";
        LogHelper.log(CLASS_NAME, Level.INFO, variation);
        assertEquals(expected, result);

        DateTime nextMonth = today.plus(0, 1, 0, 0, 0, 0, 0,
                DateTime.DayOverflow.Spillover);
        end = "-end next month 9am";
        variation = getDeadlineAddCmd(DEADLINE_DESCRIPTION, end, !IS_REORDER,
                IS_WRAPPED);
        result = parser.convertCommand(variation);
        expected = "add " + DEADLINE_DESCRIPTION +
                "-end " +
                nextMonth.format("DDMMYYYY") +
                "090000";
        assertEquals(expected, result);
    }

    @Test
    public void testEventControl() throws ParseException {

        assertEquals(addEventControlADay,
                parser.convertCommand(addEventControlADay));
        assertEquals(addEventControlDays,
                parser.convertCommand(addEventControlDays));
        assertEquals(addEventControlMonths,
                parser.convertCommand(addEventControlMonths));
        assertEquals(addEventControlYears,
                parser.convertCommand(addEventControlYears));

    }

    @Test
    public void testEventKeywords() throws ParseException {

        // Wrap and unwrapped

        // -from
        start = getTestTime(HAS_DATE_24_AUG_2014_0900, FROM_START, HAS_DASH);
        end = getTestTime(HAS_DATE_25_AUG_2014_1200, DEAFULT_END, HAS_DASH);
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_DES, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        assertEquals(addEventControlADay, result);

        // from no dash
        start = getTestTime(HAS_DATE_24_AUG_2014_0900, FROM_START, !HAS_DASH);
        end = getTestTime(HAS_DATE_25_AUG_2014_1200, DEAFULT_END, !HAS_DASH);
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_DES, IS_WRAPPED);
        result = parser.convertCommand(variation);
        assertEquals(addEventControlADay, result);

    }

    @Test
    public void testEventKeywordsReorder() throws ParseException {

        // descript end start
        start = getTestTime(HAS_DATE_24_AUG_2014_0900, DEFAULT_START, HAS_DASH);
        end = getTestTime(HAS_DATE_25_AUG_2014_1200, DEAFULT_END, HAS_DASH);
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_DES, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        assertEquals(addEventControlADay, result);

        // start descript end
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_SDE, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        assertEquals(addEventControlADay, result);

        // start end descript
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_SED, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        assertEquals(addEventControlADay, result);

        // end descript start
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_EDS, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        assertEquals(addEventControlADay, result);

        // end start descript
        variation = getEventAddCmd(EVENT_DESCRIPTION, start, end,
                ORDER_EVENT_ESD, !IS_WRAPPED);
        result = parser.convertCommand(variation);
        assertEquals(addEventControlADay, result);

    }

    @Test
    public void testModifyControl() throws ParseException {
        // checking individual flags
        variation = "modify todo 2 -description change me!";
        result = parser.convertCommand(variation);
        assertEquals("modify todo 2 -description \u2010description change me!",
                result);
    }

    @Test
    public void testModify() throws ParseException {
        variation = "modify todo 1 'whahaha' priority high";
        result = parser.convertCommand(variation);
        assertEquals("modify todo 1 -description whahaha -priority H", result);

        variation = "modify event 100 'whahaha' from 7am to 1pm";
        result = parser.convertCommand(variation);
        String resultDate = today.format("DDMMYYYY");
        start = resultDate + "070000";
        end = resultDate + "130000";
        assertEquals("modify event 100 -description whahaha -start " + start +
                " -end " +
                end, result);

        // For changing task type
        variation = "modify deadline 5 changeto event 'whahaha' from tmr 3am";
        result = parser.convertCommand(variation);
        DateTime tmr = today.plusDays(1);
        resultDate = tmr.format("DDMMYYYY");
        start = resultDate + "030000";
        assertEquals(
                "modify deadline 5 -totype event -description whahaha -start " + start,
                result);

        // For shorten id
        variation = "modify d5 changeto event 'whahaha' from tmr 3am";
        result = parser.convertCommand(variation);
        resultDate = tmr.format("DDMMYYYY");
        start = resultDate + "030000";
        assertEquals(
                "modify deadline 5 -totype event -description whahaha -start " + start,
                result);

        // For shorten id
        variation = "modify d5 -changeto event -from tmr 3am";
        result = parser.convertCommand(variation);
        resultDate = tmr.format("DDMMYYYY");
        start = resultDate + "030000";
        assertEquals("modify deadline 5 -totype event -start " + start, result);

        // For shorten id
        variation = "modify d5 -changeto event get the -description tag from mina -from tmr 3am";
        result = parser.convertCommand(variation);
        resultDate = tmr.format("DDMMYYYY");
        start = resultDate + "030000";
        assertEquals(
                "modify deadline 5 -totype event -description get the \u2010description tag from mina -start " + start,
                result);

        // delete with shorten id
        variation = "delete td1";
        result = parser.convertCommand(variation);
        assertEquals("delete todo 1", result);

        // remove with shorten id
        variation = "remove td1";
        result = parser.convertCommand(variation);
        assertEquals("delete todo 1", result);

        // complete with shorten id
        variation = "complete td1";
        result = parser.convertCommand(variation);
        assertEquals("complete todo 1", result);

        // complete with id
        variation = "complete event 9999";
        result = parser.convertCommand(variation);
        assertEquals("complete event 9999", result);

    }

    @Test
    public void testSearch() throws ParseException {

        variation = "search doors wide open";
        result = parser.convertCommand(variation);
        assertEquals("search doors//wide//open", result);

        variation = "find doors 'wide open' help me please";
        result = parser.convertCommand(variation);
        assertEquals("search wide open//doors//help//me//please", result);

        variation = "find 'wide open' help 'me please'";
        result = parser.convertCommand(variation);
        assertEquals("search wide open//me please//help", result);

        variation = "search haha hehe";
        result = parser.convertCommand(variation);
        assertEquals("search haha//hehe", result);

        variation = "search 'haha hohoh' hehe";
        result = parser.convertCommand(variation);
        assertEquals("search haha hohoh//hehe", result);

        variation = "search don't don't 'blah don't blah don't'";
        result = parser.convertCommand(variation);
        assertEquals("search blah don't blah don't//don't//don't", result);

        variation = "search 'hohoho hohoho ' 'sasads dfdf' ' vvvvv '";
        result = parser.convertCommand(variation);
        assertEquals("search hohoho hohoho//sasads dfdf//vvvvv", result);
        
        variation = "search dog 'and what the ' cats 'search -start' frodo";
        result = parser.convertCommand(variation);
        assertEquals("search and what the//search \u2010start//dog//cats//frodo", result);
        
    }

    @Test
    public void testDisplayControl() throws ParseException {

        result = parser.convertCommand("display");
        assertEquals("display", result);

        result = parser.convertCommand(displayControlType);
        assertEquals(displayControlType, result);
    }

    @Test
    public void testDisplayBasicKeywords() throws ParseException {

        variation = "show deadlines todos events complete +complete";
        result = parser.convertCommand(variation);
        assertEquals(displayControlType, result);

        variation = "filter d td e completed +complete";
        result = parser.convertCommand(variation);
        assertEquals(displayControlType, result);

        variation = "filter d td e completed all";
        result = parser.convertCommand(variation);
        assertEquals(displayControlType, result);
    }

    @Test
    public void testDisplayCompositeKeywords() throws ParseException {

        String todayDate = today.format("DDMMYYYY");

        variation = "display deadlines -agendaof today";
        result = parser.convertCommand(variation);
        assertEquals("display deadline -start " + todayDate +
                "000000" +
                " -end " +
                todayDate +
                "235959", result);

        variation = "display deadlines -agendaof tmr";
        result = parser.convertCommand(variation);
        DateTime tmr = today.plusDays(1);
        String tmrDate = tmr.format("DDMMYYYY");

        assertEquals("display deadline -start " + tmrDate +
                "000000" +
                " -end " +
                tmrDate +
                "235959", result);

        variation = "display deadlines -agendaof next 2 weeks";
        result = parser.convertCommand(variation);
        DateTime twoWeeks = today.plusDays(14);
        String twoWeeksDate = twoWeeks.format("DDMMYYYY");

        assertEquals("display deadline -start " + twoWeeksDate +
                "000000" +
                " -end " +
                twoWeeksDate +
                "235959", result);

        variation = "display deadlines -agendaof next week";
        result = parser.convertCommand(variation);
        DateTime oneWeeks = today.plusDays(7);
        String oneWeeksDate = oneWeeks.format("DDMMYYYY");

        assertEquals("display deadline -start " + oneWeeksDate +
                "000000" +
                " -end " +
                oneWeeksDate +
                "235959", result);

    }

    @Test
    public void testRecurringKeywordsControl() throws ParseException {

        result = parser.convertCommand(addRecurDayControl);
        assertEquals(addRecurDayControl, result);

        result = parser.convertCommand(addRecurWeekControl);
        assertEquals(addRecurWeekControl, result);

        result = parser.convertCommand(addRecurMonthControl);
        assertEquals(addRecurMonthControl, result);

        result = parser.convertCommand(addRecurYearControl);
        assertEquals(addRecurYearControl, result);

    }

    @Test
    public void testRecurringReorder() throws ParseException {

        variation = "add every day until 23/11/2014 'CS2103 tutorial' from 24082014090000 to 24082014110000";
        result = parser.convertCommand(variation);
        assertEquals(addRecurDayControl, result);

    }

    // XXX test for functions

    /*
     * EP: updateTaskId() 1) [action] size = 0 /invalid 2) [action] [invalid]
     * size = 1 /invalid 3) [action] [task id] size = 1 /parse with a regex 4)
     * [action] [task] [id] size = 2 /parse with another regex 4.1) [action]
     * [invalid] [id] 4.2) [action] [task] [invalid] 5) [action] [task] [id]
     * [the rest] size > 2 4,5 can be combined.
     */

    @Test(expected = ParseException.class)
    public void testUpdateTaskIdSizeOneInv() throws ParseException {
        variation = "delete 1";
        result = parser.convertCommand(variation);
    }

    @Test(expected = ParseException.class)
    public void testUpdateTaskIdInvalidId() throws ParseException {
        variation = "delete event opop";
        result = parser.convertCommand(variation);
    }

    @Test(expected = ParseException.class)
    public void testUpdateTaskIdInvalidTask() throws ParseException {
        variation = "delete blahs 1";
        result = parser.convertCommand(variation);
    }

    @Test(expected = ParseException.class)
    public void testUpdateTaskIdInvalidTaskAndId() throws ParseException {
        variation = "delete blahs lll";
        result = parser.convertCommand(variation);
    }

    @Test(expected = ParseException.class)
    public void testUpdateTaskIdInvalidTaskAndIdTogether()
            throws ParseException {
        variation = "delete sdsd3";
        result = parser.convertCommand(variation);
    }

    @Test
    public void testUpdateTaskId() throws ParseException {

        // (2)
        variation = "delete todo1";
        result = parser.convertCommand(variation);
        assertEquals("delete todo 1", result);

        variation = "delete td1";
        result = parser.convertCommand(variation);
        assertEquals("delete todo 1", result);

        // (3)
        variation = "delete todo 3";
        result = parser.convertCommand(variation);
        assertEquals("delete todo 3", result);
    }

    private String getEventAddCmd(String description, String start, String end,
            int reorderType, boolean isWrapped) {

        StringBuilder variationBuild = new StringBuilder();
        variationBuild.append("add ");

        description = (isWrapped) ? wrapDescription(description) : description;

        switch (reorderType) {
            case ORDER_EVENT_DES :
                variationBuild.append(description + " ");
                variationBuild.append(end + " ");
                variationBuild.append(start);
                break;
            case ORDER_EVENT_SDE :
                variationBuild.append(start + " ");
                variationBuild.append(description + " ");
                variationBuild.append(end);
                break;
            case ORDER_EVENT_SED :
                variationBuild.append(start + " ");
                variationBuild.append(end + " ");
                variationBuild.append(description);
                break;
            case ORDER_EVENT_ESD :
                variationBuild.append(end + " ");
                variationBuild.append(start + " ");
                variationBuild.append(description);
                break;
            case ORDER_EVENT_EDS :
                variationBuild.append(end + " ");
                variationBuild.append(description + " ");
                variationBuild.append(start);
                break;
            default :
                variationBuild.append(description + " ");
                variationBuild.append(start + " ");
                variationBuild.append(end);
        }

        return variationBuild.toString();
    }

    /**
     * Get the add deadline command
     * 
     * @param description
     * @param end
     * @param isReorder
     * @param isWrapped
     * @return
     */
    private String getDeadlineAddCmd(String description, String end,
            boolean isReorder, boolean isWrapped) {
        StringBuilder variationBuild = new StringBuilder();
        variationBuild.append("add ");

        if (isReorder) {
            variationBuild.append(end);
        }

        if (isWrapped) {
            variationBuild.append(wrapDescription(description));
        } else {
            variationBuild.append(description + " ");
        }

        if (!isReorder) {
            variationBuild.append(end);
        }
        return variationBuild.toString();
    }

    /**
     * Get the test time
     * 
     * @param type Type of date
     * @param keywordType what's the keyword type
     * @param hasDash
     * @return
     */
    private String getTestTime(int type, int keywordType, boolean hasDash) {

        String endType = getTimeType(keywordType, hasDash);

        switch (type) {
            case HAS_SECS :
                return endType + " 26042013235923 ";
            case HAS_NO_SECS :
                return endType + " 260420132359 ";
            case HAS_TODAY_NO_TIME_SLASH :
                return endType + " " + today.format("DD/MM/YYYY");
            case HAS_TODAY_NO_TIME_DOT :
                return endType + " " + today.format("DD.MM.YYYY");
            case HAS_TODAY_NO_TIME_DASH :
                return endType + " " + today.format("DD-MM-YYYY");
            case HAS_TODAY_NO_TIME_KEYWORD :
                return endType + " today";
            case HAS_TODAY_TIME :
                return endType + " today 2000";
            case HAS_TODAY_TIME_AM :
                return endType + " today 9am";
            case HAS_NO_DATE_BUT_TIME_PM :
                return endType + " 8pm";
            case HAS_NO_DATE_BUT_MILITARY_TIME :
                return endType + " 2000";
            case HAS_DATE_24_AUG_2014_0900 :
                return endType + " 24082014090000";
            case HAS_DATE_25_AUG_2014_1200 :
                return endType + " 25082014120000";
            case HAS_DATE_24_AUG_2014_2133 :
                return endType + " 24082014121330";

                // // start: 24th of August 2014 0900 - 25th of August 2014 1200
                // addEventControlADay =
                // "add meet friends -start 24082014090000 -end 25082014120000";
                // // start: 24th of August 2014 0900 - 31th of August 2014 1200
                // addEventControlDays =
                // "add meet friends -start 24082014090000 -end 31082014120000";
                // // start: 24th of August 2014 0900 - 24th of September 2014
                // 1200
                // addEventControlMonths =
                // "add meet friends -start 24082014090000 -end 24092014120000";
                // // start: 24th of August 2014 0900 - 24th of September 2017
                // 1200
                // addEventControlYears =
                // "add meet friends -start 24082014090000 -end 24092017120000";
            default :
                return "";
        }
    }

    private String getTimeType(int keywordType, boolean hasDash) {

        String timeType = "";

        if (hasDash) {
            timeType += "-";
        }

        switch (keywordType) {
            case DEAFULT_END :
                return timeType + "end";
            case DUE_END :
                return timeType + "due";
            case BY_END :
                return timeType + "by";
            case BEFORE_END :
                return timeType + "before";
            case DEFAULT_START :
                return timeType + "start";
            case FROM_START :
                return timeType + "from";
            case STARTING_START :
                return timeType + "starting";
            default :
                return "";
        }
    }

    private String getTestTime(int type) {
        return getTestTime(type, DEAFULT_END, true);
    }

    private String wrapDescription(String descript) {
        return "'" + descript + "' ";
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\CommandParserTest.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\AddCommandTest.java
	 */


public class AddCommandTest {
    
    
    private AddCommand commandFormat; 
    
    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        KeywordFactory.initialiseKeywordFactory();
    }

    @Before
    public void setUp() throws Exception {
    }

    @Test
    public void testNormalNoKeyword() throws ParseException {
        String result = "add testing one two three";
        commandFormat = getCommandFormat(CommandType.ADD, "testing one two three");
        assertEquals(result, commandFormat.parseArgument());
    }
    
    @Test
    public void testWrapping() throws ParseException {
        String result = "add testing one two three with wrap";
        commandFormat = getCommandFormat(CommandType.ADD, "'testing one two three with wrap'");
        assertEquals(result, commandFormat.parseArgument());        
    }
    
    @Test
    public void testRecognisingKeyword() throws ParseException {
        String result = "add testing one two three -priority H";
        commandFormat = getCommandFormat(CommandType.ADD, "-priority H testing one two three");
        assertEquals(result, commandFormat.parseArgument());             
    }
    
    @Test
    public void testRecognisingKeywordWithWrapping() throws ParseException {
        String result = "add testing one two three -priority H";
        commandFormat = getCommandFormat(CommandType.ADD, "'testing one two three' high priority");
        assertEquals(result, commandFormat.parseArgument());           
        
        commandFormat = getCommandFormat(CommandType.ADD, "high priority 'testing one two three'");
        assertEquals(result, commandFormat.parseArgument());   
    }
    
    private AddCommand getCommandFormat(CommandType type, String argumentStr) {
        return new AddCommand(type, argumentStr);
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\AddCommandTest.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\DescriptionKeywordTest.java
	 */


public class DescriptionKeywordTest {

    private DescriptionKeyword descript;
    private ArrayList<String> tokens;
    private Argument argument;

    private static String control;
    private static final String CLASS_NAME = DescriptionKeywordTest.class
            .getName();

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        control = "hello bye world what ";
    }

    @Before
    public void setUp() {
        argument = new Argument();
        tokens = new ArrayList<String>();
        String[] tokensArr = control.split(" ");
        descript = new DescriptionKeyword();

        for (int i = 0; i < tokensArr.length; i++) {
            tokens.add(tokensArr[i]);
        }
    }

    @Test
    public void testUpdatingTokens() throws ParseException {

        LogHelper
                .log(CLASS_NAME, Level.INFO,
                        "Testing to see if tokens are updated with null value in place");

        tokens = descript.processKeyword(tokens, 0, argument);
        int size = tokens.size();

        assertNull(tokens.get(0));
        assertEquals(size, tokens.size());
    }

    @Test
    public void testDescription() throws ParseException {

        LogHelper.log(CLASS_NAME, Level.INFO,
                "Testing to see if descriptions are added correctly.");

        for (int i = 0; i < tokens.size(); i++) {
            tokens = descript.processKeyword(tokens, i, argument);
            LogHelper.log(CLASS_NAME, Level.INFO,
                    "tokens are: " + tokens.toString());
        }
        assertEquals(control,
                argument.getKeywordValue(SimpleKeyword.DESCRIPTION));

        // check to see whether we have all nulls
        LogHelper.log(CLASS_NAME, Level.INFO,
                "Testing to see if all of entires are nullified");
        for (int i = 0; i < tokens.size(); i++) {
            assertNull(tokens.get(i));
        }
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\DescriptionKeywordTest.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\KeywordFactoryTest.java
	 */


public class KeywordFactoryTest {

    private static final String CLASS_NAME = KeywordFactoryTest.class.getName();
    private static final String WRONG_CLASS = "Expceted $1%s. Got $2%s instead";
    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        KeywordFactory.initialiseKeywordFactory();
    }

    
    @Test
    public void testKeywordsRegisteration() throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        
        log("Testing to see if classes can be loaded");
        
        Method initKeywordClassesMethod = KeywordFactory.class.getDeclaredMethod("initKeywordClasses", StandardKeyword[].class); 
        initKeywordClassesMethod.setAccessible(true);
        
        try {
            invokeInitClasses(initKeywordClassesMethod);
        } catch (ClassNotFoundException e) {
            log("Not all classs are loaded");
            fail(e.getMessage());
        }
        
        log("All classes loaded properly!");
    }
    
    @Test
    public void testAliasRegistration() throws Exception {
        
        log("Testing to see if aliases are registered correctly");
        
        LinkedHashMap<String, Keyword> aliasMap = getAliasMap();
        
        for(String alias: aliasMap.keySet()) {
            Keyword keyword = aliasMap.get(alias);
            String fullClassName = keyword.getClass().getName();
            String keywordClass = fullClassName.substring(fullClassName.lastIndexOf(".") + 1);
            if(!isRegisteredInStandardKeyword(keywordClass)) {
                fail("No such class in enum: " + keywordClass);
            }
        }
        
    }
    
    @Test
    public void testCreateKeyword() throws Exception {
        
        log("Testing to see if keywords are created correctly.");
        
        Method createKeyword = Keyword.class.getDeclaredMethod("createKeyword", new Class[]{}); 
        createKeyword.setAccessible(true);
        
        LinkedHashMap<String, Keyword> aliasMap = getAliasMap();   
        for(String alias: aliasMap.keySet()) {
            Keyword protoype = aliasMap.get(alias);
            String prototypeClass = protoype.getClass().getName();
            
            Keyword keyword = (Keyword)createKeyword.invoke(protoype);
            String keywordClass="NoClass";
            if(keyword!=null) {
                keywordClass = keyword.getClass().getName();
            } else {
                fail(prototypeClass + " createKeyword() returns null!");
            }
            
            if(!keywordClass.equals(prototypeClass)) {
                String err = String.format(WRONG_CLASS, prototypeClass, keywordClass);
                fail(err);
            }
        }
    }
    
    private boolean isRegisteredInStandardKeyword(String keywordClass) {
        //For standardKeyword first
        if(!isRegisteredInEnum(keywordClass, SimpleKeyword.values())){
            return isRegisteredInEnum(keywordClass, CompositeKeyword.values());
        }
        return true;
    }

    private boolean isRegisteredInEnum(String keywordClass,
            StandardKeyword[] values) {
        for(StandardKeyword type: values) {
            String className = type.getFilePrefix() + "Keyword";
            log("Testing " + keywordClass + " against " + className);
            if(className.equals(keywordClass)) {
                return true;
            }
        }
        return false;
    }

    @SuppressWarnings("unchecked")
    private LinkedHashMap<String, Keyword> getAliasMap() throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        Method getAliasMapMethod = KeywordFactory.class.getDeclaredMethod("getAliasMap", new Class[]{}); 
        getAliasMapMethod.setAccessible(true);
        
        
        return (LinkedHashMap<String, Keyword>) getAliasMapMethod.invoke(KeywordFactory.class);
    }
    
    private void invokeInitClasses(Method initKeywordClassesMethod) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, ClassNotFoundException{
        initKeywordClassesMethod.invoke(KeywordFactory.class, (Object)SimpleKeyword.values());
        initKeywordClassesMethod.invoke(KeywordFactory.class, (Object)CompositeKeyword.values()); 
    }
    
    private void log(String message) {
        LogHelper.log(CLASS_NAME, Level.INFO, message);
    }
    
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\KeywordFactoryTest.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\PriorityKeywordTest.java
	 */


public class PriorityKeywordTest {

    private static final String CLASS_NAME = PriorityKeywordTest.class
            .getName();
    private static String suffixControl;
    private static String suffixNoDelimitControl;
    private static String prefixControl;
    private static ArrayList<String> allNull;

    private ArrayList<String> prefixTokens;
    private ArrayList<String> suffixTokens;
    private ArrayList<String> suffixTokensNoDelimitTokens;

    private Argument argument;

    private PriorityKeyword priority;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        prefixControl = "low priority";
        suffixControl = "-priority high";
        suffixNoDelimitControl = "priority med";

        allNull = new ArrayList<String>();
        allNull.add(null);
        allNull.add(null);
    }

    @Before
    public void setUp() {
        priority = new PriorityKeyword();
        prefixTokens = new ArrayList<String>();
        suffixTokens = new ArrayList<String>();
        argument = new Argument();

        suffixTokensNoDelimitTokens = new ArrayList<String>();

        String[] prefixTokensArr = prefixControl.split(" ");
        String[] suffixTokensArr = suffixControl.split(" ");
        String[] suffixTokensNoDelimitTokensArr = suffixNoDelimitControl
                .split(" ");

        for (int i = 0; i < prefixTokensArr.length; i++) {
            prefixTokens.add(prefixTokensArr[i]);
        }

        for (int i = 0; i < suffixTokensArr.length; i++) {
            suffixTokens.add(suffixTokensArr[i]);
        }

        for (int i = 0; i < suffixTokensNoDelimitTokensArr.length; i++) {
            suffixTokensNoDelimitTokens.add(suffixTokensNoDelimitTokensArr[i]);
        }
    }

    @Test(expected = AssertionError.class)
    public void testNull() throws ParseException {
        priority.processKeyword(null, 0, argument);
    }

    @Test(expected = ParseException.class)
    public void testInvalidSuffixValue() throws ParseException {
        String invSuffixControl = "priority blah";
        ArrayList<String> invTokens = getInvalidTokens(invSuffixControl);
        invTokens = priority.processKeyword(invTokens, 0, argument);
    }

    @Test(expected = ParseException.class)
    public void testInvalidSuffixDelimitValue() throws ParseException {
        String invSuffixControl = "-priority blah";
        ArrayList<String> invTokens = getInvalidTokens(invSuffixControl);
        invTokens = priority.processKeyword(invTokens, 0, argument);
    }

    @Test(expected = ParseException.class)
    public void testPrefixValue() throws ParseException {
        String invSuffixControl = "blah priority";
        ArrayList<String> invTokens = getInvalidTokens(invSuffixControl);
        invTokens = priority.processKeyword(invTokens, 1, argument);
    }

    @Test(expected = ParseException.class)
    public void testPrefixWithDelimitValue() throws ParseException {
        String invSuffixControl = "H -priority";
        ArrayList<String> invTokens = getInvalidTokens(invSuffixControl);
        invTokens = priority.processKeyword(invTokens, 1, argument);
    }

    @Test(expected = ParseException.class)
    public void testNoValue() throws ParseException {
        String invSuffixControl = "priority";
        ArrayList<String> invTokens = getInvalidTokens(invSuffixControl);
        invTokens = priority.processKeyword(invTokens, 0, argument);
    }

    @Test
    public void testPrefix() throws ParseException {
        LogHelper.log(CLASS_NAME,Level.INFO,"Testing priority prefix");
        prefixTokens = priority.processKeyword(prefixTokens, 1, argument);

        assertEquals("L", argument.getKeywordValue(SimpleKeyword.PRIORITY)
                .trim());

        LogHelper.log(CLASS_NAME,Level.INFO,"Testing to ensure that all entries are null");
        assertEquals(allNull, prefixTokens);
    }

    @Test
    public void testSuffix() throws ParseException {
        LogHelper.log(CLASS_NAME,Level.INFO,"Testing priority suffix");
        suffixTokens = priority.processKeyword(suffixTokens, 0, argument);

        assertEquals("H", argument.getKeywordValue(SimpleKeyword.PRIORITY)
                .trim());

        LogHelper.log(CLASS_NAME,Level.INFO,"Testing to ensure that all entries are null");
        assertEquals(allNull, suffixTokens);
    }

    @Test
    public void testSuffixNoDelmit() throws ParseException {
        LogHelper.log(CLASS_NAME,Level.INFO,"Testing priority suffix but with no delimiter");
        suffixTokensNoDelimitTokens = priority.processKeyword(
                suffixTokensNoDelimitTokens, 0, argument);

        assertEquals("M", argument.getKeywordValue(SimpleKeyword.PRIORITY)
                .trim());

        LogHelper.log(CLASS_NAME, Level.INFO,"Testing to ensure that all entries are null");
        assertEquals(allNull, suffixTokensNoDelimitTokens);
    }

    private ArrayList<String> getInvalidTokens(String invString) {
        ArrayList<String> invTokens = new ArrayList<String>();
        Collections.addAll(invTokens, invString.split(" "));
        return invTokens;
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\PriorityKeywordTest.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\StartKeywordTest.java
	 */


public class StartKeywordTest {

    private StartKeyword startKeyword;
    private ArrayList<String> tokens;
    private String todayDate;
    private Argument argument;

    private static String timeOnlyControl, dateOnlyControl, timeDateControl,
            dateTimeControl;
    private static String timeResultContol, dateResultControl;

    private static String dateWordOnlyControl, dateWordTimeControl,
            timeDateWordControl;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        String keyword = "-start ";
        String date = "12/3/2004 ";
        String time = "4am ";

        timeOnlyControl = keyword + time;
        dateOnlyControl = keyword + date;
        timeDateControl = keyword + time + date;
        dateTimeControl = keyword + date + time;

        dateWordOnlyControl = keyword + "today";
        dateWordTimeControl = keyword + "today " + time;
        timeDateWordControl = keyword + time + "today";

        timeResultContol = "040000";
        dateResultControl = "12032004";
    }

    @Before
    public void setUp() throws Exception {
        DateTime today = DateTime.today(TimeZone.getDefault());
        todayDate = today.format(DateUtil.MILITARY_DATE_FORMAT.toUpperCase());
        startKeyword = new StartKeyword();
        tokens = new ArrayList<String>();
        argument = new Argument();
    }

    @Test(expected = ParseException.class)
    public void testInvTwoArgument() throws ParseException {
        ArrayList<String> inv = new ArrayList<String>();
        inv.add("-start");
        inv.add("bah");
        inv.add("mah");
        startKeyword.processKeyword(inv, 0, argument);
    }

    @Test(expected = ParseException.class)
    public void testInvOneArgument() throws ParseException {
        ArrayList<String> inv = new ArrayList<String>();
        inv.add("-start");
        inv.add("bah");
        startKeyword.processKeyword(inv, 0, argument);
    }

    @Test(expected = ParseException.class)
    public void testInvNoArgument() throws ParseException {
        ArrayList<String> inv = new ArrayList<String>();
        inv.add("-start");
        startKeyword.processKeyword(inv, 0, argument);
    }

    @Test
    public void testTimeOnly() throws ParseException {
        tokens = tokenize(timeOnlyControl);
        tokens = startKeyword.processKeyword(tokens, 0, argument);
        String expected = todayDate + timeResultContol;
        assertEquals(expected, argument.getKeywordValue(SimpleKeyword.START)
                .trim());
    }

    @Test
    public void testDateOnly() throws ParseException {
        tokens = tokenize(dateOnlyControl);
        tokens = startKeyword.processKeyword(tokens, 0, argument);
        String expected = dateResultControl + "000000";
        assertEquals(expected, argument.getKeywordValue(SimpleKeyword.START)
                .trim());
    }

    @Test
    public void testTimeDateOrder() throws ParseException {
        tokens = tokenize(timeDateControl);
        tokens = startKeyword.processKeyword(tokens, 0, argument);
        String expected = dateResultControl + timeResultContol;
        assertEquals(expected, argument.getKeywordValue(SimpleKeyword.START)
                .trim());
    }

    @Test
    public void testDateTimeOrder() throws ParseException {
        tokens = tokenize(dateTimeControl);
        tokens = startKeyword.processKeyword(tokens, 0, argument);
        String expected = dateResultControl + timeResultContol;
        assertEquals(expected, argument.getKeywordValue(SimpleKeyword.START)
                .trim());
    }

    @Test
    public void testDateWordOnly() throws ParseException {
        tokens = tokenize(dateWordOnlyControl);
        tokens = startKeyword.processKeyword(tokens, 0, argument);
        String expected = todayDate + "000000";
        assertEquals(expected, argument.getKeywordValue(SimpleKeyword.START)
                .trim());
    }

    @Test
    public void testDateWordTime() throws ParseException {
        tokens = tokenize(dateWordTimeControl);
        tokens = startKeyword.processKeyword(tokens, 0, argument);
        String expected = todayDate + timeResultContol;
        assertEquals(expected, argument.getKeywordValue(SimpleKeyword.START)
                .trim());
    }

    @Test
    public void testTimeDateWord() throws ParseException {
        tokens = tokenize(timeDateWordControl);
        tokens = startKeyword.processKeyword(tokens, 0, argument);
        String expected = todayDate + timeResultContol;
        assertEquals(expected, argument.getKeywordValue(SimpleKeyword.START)
                .trim());
    }

    private ArrayList<String> tokenize(String argument) {
        ArrayList<String> newTokens = new ArrayList<String>();
        String[] rawTokens = argument.split(" ");
        Collections.addAll(newTokens, rawTokens);
        return newTokens;
    }

}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\StartKeywordTest.java





	/**
	 * origin: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\TaskIdKeywordTest.java
	 */


public class TaskIdKeywordTest {
    
    private TaskIdKeyword taskId;
    
    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
    }

    @Before
    public void setUp() throws Exception {
        taskId = new TaskIdKeyword();
    }
    
    @Test
    public void testExtractTaskId() throws ParseException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException{
        Method extractTaskId = TaskIdKeyword.class.getDeclaredMethod("extractTaskId", String.class);
        extractTaskId.setAccessible(true);
        
        String result = (String)extractTaskId.invoke(taskId, "todo 1");
        assertEquals("todo 1", result);
        
        result = (String)extractTaskId.invoke(taskId, "td 1");
        assertEquals("td 1", result);
        
        result = (String)extractTaskId.invoke(taskId, "td1");
        assertEquals("td1", result);
        
        result = (String)extractTaskId.invoke(taskId, "td1 ccvcv");
        assertEquals("td1", result);
        
        result = (String)extractTaskId.invoke(taskId, "xcxc td1");
        assertNull(result);
    }
    
    @SuppressWarnings("unchecked")
    @Test
    public void testNullifyTokens() throws ParseException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        Method nullifyTokens = TaskIdKeyword.class.getDeclaredMethod("nullifyTokens", new Class[]{String.class, ArrayList.class, Integer.class});
        nullifyTokens.setAccessible(true);
        
        ArrayList<String> testTokens, result, expected;

        testTokens = tokenize("sss -block todo 1 what the ehll?");
        result = (ArrayList<String>)nullifyTokens.invoke(taskId, "todo 1", testTokens, 1);
        expected = tokenize("sss @@!! @@!! @@!! what the ehll?");
        assertEquals(expected, result);
        
        testTokens = tokenize("sss -block td1 what the ehll?");
        result = (ArrayList<String>)nullifyTokens.invoke(taskId, "td1", testTokens, 1);
        expected = tokenize("sss @@!! @@!! what the ehll?");
        assertEquals(expected, result);
    }
    
    @Test
    public void testProcessTaskId() throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        Method processTaskId = TaskIdKeyword.class.getDeclaredMethod("processTaskId",String.class);
        processTaskId.setAccessible(true);
        
        String rawTaskId, expected, result;
        
        rawTaskId = "td1";
        result = (String)processTaskId.invoke(taskId, rawTaskId);
        expected = "todo 1";
        assertEquals(expected, result);
        
        rawTaskId = "todo 1";
        result = (String)processTaskId.invoke(taskId, rawTaskId);
        expected = "todo 1";
        assertEquals(expected, result);
        
        rawTaskId = "td 11";
        result = (String)processTaskId.invoke(taskId, rawTaskId);
        expected = "todo 11";
        assertEquals(expected, result);
    }
    
    private ArrayList<String> tokenize(String cmd) {
        String[] tokens = cmd.split(" ");
        ArrayList<String> testTokens = new ArrayList<String>();
        
        for(int i=0; i<tokens.length; i++) {
            String token;
            if(!tokens[i].equals("@@!!")) {
                token = tokens[i]; 
            } else {
                token = null;
            }
            testTokens.add(token);
        }

        return testTokens;
    }
}

	// End of segment: C:\Users\Sony\Desktop\cs2103jan2014-w09-1j\src\test\java\sg\edu\nus\cs2103t\mina\test\commandcontroller\keyword\TaskIdKeywordTest.java





